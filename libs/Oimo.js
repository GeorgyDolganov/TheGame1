// lo-th.github.io/Oimo.js/license
!(function (t, i) { typeof exports === 'object' && typeof module !== 'undefined' ? i(exports) : typeof define === 'function' && define.amd ? define(['exports'], i) : i((t = t || self).OIMO = {}); }(this, (t) => {
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t; }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, 'name', { get() { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]; } }), void 0 === Object.assign && (Object.assign = function (t) { if (t == null) throw new TypeError('Cannot convert undefined or null to object'); for (var i = Object(t), s = 1; s < arguments.length; s++) { const h = arguments[s]; if (h != null) for (const e in h)Object.prototype.hasOwnProperty.call(h, e) && (i[e] = h[e]); } return i; }); let s; let h; let e; let a; const o = '1.0.9'; const n = 0; const r = 1; const l = 2; const c = 3; const m = 0; const p = 0; const u = 1; const y = 2; const x = 3; const d = 4; const f = 5; const b = 0; const v = 1; const z = 2; const N = 3; const k = 4; const w = 5; const M = 6; var g = {
    sqrt: Math.sqrt, abs: Math.abs, floor: Math.floor, cos: Math.cos, sin: Math.sin, acos: Math.acos, asin: Math.asin, atan2: Math.atan2, round: Math.round, pow: Math.pow, max: Math.max, min: Math.min, random: Math.random, degtorad: 0.017453292519943295, radtodeg: 57.29577951308232, PI: 3.141592653589793, TwoPI: 6.283185307179586, PI90: 1.570796326794896, PI270: 4.712388980384689, INF: 1 / 0, EPZ: 1e-5, EPZ2: 1e-6, lerp(t, i, s) { return (1 - s) * t + s * i; }, randInt(t, i) { return t + g.floor(g.random() * (i - t + 1)); }, rand(t, i) { return t + g.random() * (i - t); }, generateUUID: (h = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), e = new Array(36), a = 0, function () { for (let t = 0; t < 36; t++)t === 8 || t === 13 || t === 18 || t === 23 ? e[t] = '-' : t === 14 ? e[t] = '4' : (a <= 2 && (a = 33554432 + 16777216 * Math.random() | 0), s = 15 & a, a >>= 4, e[t] = h[t === 19 ? 3 & s | 8 : s]); return e.join(''); }), int(t) { return g.floor(t); }, fix(t, i) { return t.toFixed(i || 3, 10); }, clamp(t, i, s) { return g.max(i, g.min(s, t)); }, distance(t, i) { const s = i[0] - t[0]; const h = i[1] - t[1]; const e = i[2] - t[2]; return g.sqrt(s * s + h * h + e * e); }, acosClamp(t) { return t > 1 ? 0 : t < -1 ? g.PI : g.acos(t); }, distanceVector(t, i) { const s = t.x - i.x; const h = t.y - i.y; const e = t.z - i.z; return s * s + h * h + e * e; }, dotVectors(t, i) { return t.x * i.x + t.y * i.y + t.z * i.z; },
  }; function I(t, i) { console.error(`[OIMO] ${t}: ${i}`); } function V(t) { this.parent = t, this.infos = new Float32Array(13), this.f = [0, 0, 0], this.times = [0, 0, 0, 0], this.broadPhase = this.parent.broadPhaseType, this.version = o, this.fps = 0, this.tt = 0, this.broadPhaseTime = 0, this.narrowPhaseTime = 0, this.solvingTime = 0, this.totalTime = 0, this.updateTime = 0, this.MaxBroadPhaseTime = 0, this.MaxNarrowPhaseTime = 0, this.MaxSolvingTime = 0, this.MaxTotalTime = 0, this.MaxUpdateTime = 0; } function L(t, i, s) { this.x = t || 0, this.y = i || 0, this.z = s || 0; } function S(t, i, s, h) { this.x = t || 0, this.y = i || 0, this.z = s || 0, this.w = void 0 !== h ? h : 1; } function P(t, i, s, h, e, a, o, n, r) { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error('OIMO.Mat33: the constructor no longer reads arguments. use .set() instead.'); } function T(t, i, s, h, e, a) { this.elements = new Float32Array(6); const o = this.elements; o[0] = t || 0, o[1] = s || 0, o[2] = e || 0, o[3] = i || 0, o[4] = h || 0, o[5] = a || 0; }Object.assign(V.prototype, {
    setTime(t) { this.times[t || 0] = performance.now(); }, resetMax() { this.MaxBroadPhaseTime = 0, this.MaxNarrowPhaseTime = 0, this.MaxSolvingTime = 0, this.MaxTotalTime = 0, this.MaxUpdateTime = 0; }, calcBroadPhase() { this.setTime(2), this.broadPhaseTime = this.times[2] - this.times[1]; }, calcNarrowPhase() { this.setTime(3), this.narrowPhaseTime = this.times[3] - this.times[2]; }, calcEnd() { this.setTime(2), this.solvingTime = this.times[2] - this.times[1], this.totalTime = this.times[2] - this.times[0], this.updateTime = this.totalTime - (this.broadPhaseTime + this.narrowPhaseTime + this.solvingTime), this.tt === 100 && this.resetMax(), this.tt > 100 && (this.broadPhaseTime > this.MaxBroadPhaseTime && (this.MaxBroadPhaseTime = this.broadPhaseTime), this.narrowPhaseTime > this.MaxNarrowPhaseTime && (this.MaxNarrowPhaseTime = this.narrowPhaseTime), this.solvingTime > this.MaxSolvingTime && (this.MaxSolvingTime = this.solvingTime), this.totalTime > this.MaxTotalTime && (this.MaxTotalTime = this.totalTime), this.updateTime > this.MaxUpdateTime && (this.MaxUpdateTime = this.updateTime)), this.upfps(), this.tt++, this.tt > 500 && (this.tt = 0); }, upfps() { this.f[1] = Date.now(), this.f[1] - 1e3 > this.f[0] && (this.f[0] = this.f[1], this.fps = this.f[2], this.f[2] = 0), this.f[2]++; }, show() { return [`Oimo.js ${this.version}<br>`, `${this.broadPhase}<br><br>`, `FPS: ${this.fps} fps<br><br>`, `rigidbody ${this.parent.numRigidBodies}<br>`, `contact &nbsp;&nbsp;${this.parent.numContacts}<br>`, `ct-point &nbsp;${this.parent.numContactPoints}<br>`, `paircheck ${this.parent.broadPhase.numPairChecks}<br>`, `island &nbsp;&nbsp;&nbsp;${this.parent.numIslands}<br><br>`, 'Time in milliseconds<br><br>', `broadphase &nbsp;${g.fix(this.broadPhaseTime)} | ${g.fix(this.MaxBroadPhaseTime)}<br>`, `narrowphase ${g.fix(this.narrowPhaseTime)} | ${g.fix(this.MaxNarrowPhaseTime)}<br>`, `solving &nbsp;&nbsp;&nbsp;&nbsp;${g.fix(this.solvingTime)} | ${g.fix(this.MaxSolvingTime)}<br>`, `total &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${g.fix(this.totalTime)} | ${g.fix(this.MaxTotalTime)}<br>`, `updating &nbsp;&nbsp;&nbsp;${g.fix(this.updateTime)} | ${g.fix(this.MaxUpdateTime)}<br>`].join('\n'); }, toArray() { return this.infos[0] = this.parent.broadPhase.types, this.infos[1] = this.parent.numRigidBodies, this.infos[2] = this.parent.numContacts, this.infos[3] = this.parent.broadPhase.numPairChecks, this.infos[4] = this.parent.numContactPoints, this.infos[5] = this.parent.numIslands, this.infos[6] = this.broadPhaseTime, this.infos[7] = this.narrowPhaseTime, this.infos[8] = this.solvingTime, this.infos[9] = this.updateTime, this.infos[10] = this.totalTime, this.infos[11] = this.fps, this.infos; },
  }), Object.assign(L.prototype, {
    Vec3: !0, set(t, i, s) { return this.x = t, this.y = i, this.z = s, this; }, add(t, i) { return void 0 !== i ? this.addVectors(t, i) : (this.x += t.x, this.y += t.y, this.z += t.z, this); }, addVectors(t, i) { return this.x = t.x + i.x, this.y = t.y + i.y, this.z = t.z + i.z, this; }, addEqual(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this; }, sub(t, i) { return void 0 !== i ? this.subVectors(t, i) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this); }, subVectors(t, i) { return this.x = t.x - i.x, this.y = t.y - i.y, this.z = t.z - i.z, this; }, subEqual(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this; }, scale(t, i) { return this.x = t.x * i, this.y = t.y * i, this.z = t.z * i, this; }, scaleEqual(t) { return this.x *= t, this.y *= t, this.z *= t, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this; }, addScaledVector(t, i) { return this.x += t.x * i, this.y += t.y * i, this.z += t.z * i, this; }, subScaledVector(t, i) { return this.x -= t.x * i, this.y -= t.y * i, this.z -= t.z * i, this; }, cross(t, i) { if (void 0 !== i) return this.crossVectors(t, i); const s = this.x; const h = this.y; const e = this.z; return this.x = h * t.z - e * t.y, this.y = e * t.x - s * t.z, this.z = s * t.y - h * t.x, this; }, crossVectors(t, i) { const s = t.x; const h = t.y; const e = t.z; const a = i.x; const o = i.y; const n = i.z; return this.x = h * n - e * o, this.y = e * a - s * n, this.z = s * o - h * a, this; }, tangent(t) { const i = t.x; const s = t.y; const h = t.z; return this.x = s * i - h * h, this.y = -h * s - i * i, this.z = i * h + s * s, this; }, invert(t) { return this.x = -t.x, this.y = -t.y, this.z = -t.z, this; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z; }, addition() { return this.x + this.y + this.z; }, lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z; }, length() { return g.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this; }, applyMatrix3(t, i) { const s = this.x; const h = this.y; const e = this.z; const a = t.elements; return i ? (this.x = a[0] * s + a[1] * h + a[2] * e, this.y = a[3] * s + a[4] * h + a[5] * e, this.z = a[6] * s + a[7] * h + a[8] * e) : (this.x = a[0] * s + a[3] * h + a[6] * e, this.y = a[1] * s + a[4] * h + a[7] * e, this.z = a[2] * s + a[5] * h + a[8] * e), this; }, applyQuaternion(t) { const i = this.x; const s = this.y; const h = this.z; const e = t.x; const a = t.y; const o = t.z; const n = t.w; const r = n * i + a * h - o * s; const l = n * s + o * i - e * h; const c = n * h + e * s - a * i; const m = -e * i - a * s - o * h; return this.x = r * n + m * -e + l * -o - c * -a, this.y = l * n + m * -a + c * -e - r * -o, this.z = c * n + m * -o + r * -a - l * -e, this; }, testZero() { return this.x !== 0 || this.y !== 0 || this.z !== 0; }, testDiff(t) { return !this.equals(t); }, equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z; }, clone() { return new this.constructor(this.x, this.y, this.z); }, toString() { return `Vec3[${this.x.toFixed(4)}, ${this.y.toFixed(4)}, ${this.z.toFixed(4)}]`; }, multiplyScalar(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this; }, divideScalar(t) { return this.multiplyScalar(1 / t); }, normalize() { return this.divideScalar(this.length()); }, toArray(t, i) { void 0 === i && (i = 0), t[i] = this.x, t[i + 1] = this.y, t[i + 2] = this.z; }, fromArray(t, i) { return void 0 === i && (i = 0), this.x = t[i], this.y = t[i + 1], this.z = t[i + 2], this; },
  }), Object.assign(S.prototype, {
    Quat: !0,
    set(t, i, s, h) { return this.x = t, this.y = i, this.z = s, this.w = h, this; },
    addTime(t, i) { const s = t.x; const h = t.y; const e = t.z; const a = this.w; const o = this.x; const n = this.y; const r = this.z; return i *= 0.5, this.x += i * (s * a + h * r - e * n), this.y += i * (h * a + e * o - s * r), this.z += i * (e * a + s * n - h * o), this.w += i * (-s * o - h * n - e * r), this.normalize(), this; },
    multiply(t, i) { return void 0 !== i ? this.multiplyQuaternions(t, i) : this.multiplyQuaternions(this, t); },
    multiplyQuaternions(t, i) { const s = t.x; const h = t.y; const e = t.z; const a = t.w; const o = i.x; const n = i.y; const r = i.z; const l = i.w; return this.x = s * l + a * o + h * r - e * n, this.y = h * l + a * n + e * o - s * r, this.z = e * l + a * r + s * n - h * o, this.w = a * l - s * o - h * n - e * r, this; },
    setFromUnitVectors(t, i) {
      const s = new L(); let
        h = t.dot(i) + 1; return h < g.EPS2 ? (h = 0, g.abs(t.x) > g.abs(t.z) ? s.set(-t.y, t.x, 0) : s.set(0, -t.z, t.y)) : s.crossVectors(t, i), this._x = s.x, this._y = s.y, this._z = s.z, this._w = h, this.normalize();
    },
    arc(t, i) { const s = t.x; const h = t.y; const e = t.z; let a = i.x; let o = i.y; let n = i.z; let r = s * a + h * o + e * n; if (r == -1) return a = h * s - e * e, o = -e * h - s * s, n = s * e + h * h, r = 1 / g.sqrt(a * a + o * o + n * n), this.w = 0, this.x = a * r, this.y = o * r, this.z = n * r, this; const l = h * n - e * o; const c = e * a - s * n; const m = s * o - h * a; return this.w = g.sqrt(0.5 * (1 + r)), r = 0.5 / this.w, this.x = l * r, this.y = c * r, this.z = m * r, this; },
    normalize() { let t = this.length(); return t === 0 ? this.set(0, 0, 0, 1) : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this.w *= t), this; },
    inverse() { return this.conjugate().normalize(); },
    invert(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this.conjugate().normalize(), this; },
    conjugate() { return this.x *= -1, this.y *= -1, this.z *= -1, this; },
    length() { return g.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w); },
    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; },
    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this; },
    clone(t) { return new S(this.x, this.y, this.z, this.w); },
    testDiff(t) { return !this.equals(t); },
    equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w; },
    toString() { return `Quat[${this.x.toFixed(4)}, (${this.y.toFixed(4)}, ${this.z.toFixed(4)}, ${this.w.toFixed(4)})]`; },
    setFromEuler(t, i, s) { const h = Math.cos(0.5 * t); const e = Math.cos(0.5 * i); const a = Math.cos(0.5 * s); const o = Math.sin(0.5 * t); const n = Math.sin(0.5 * i); const r = Math.sin(0.5 * s); return this.x = o * e * a + h * n * r, this.y = h * n * a - o * e * r, this.z = h * e * r + o * n * a, this.w = h * e * a - o * n * r, this; },
    setFromAxis(t, i) { t.normalize(), i *= 0.5; const s = g.sin(i); return this.x = s * t.x, this.y = s * t.y, this.z = s * t.z, this.w = g.cos(i), this; },
    setFromMat33(t) { let i; const s = t[0] + t[4] + t[8]; if (s > 0)i = g.sqrt(s + 1), this.w = 0.5 / i, i = 0.5 / i, this.x = (t[5] - t[7]) * i, this.y = (t[6] - t[2]) * i, this.z = (t[1] - t[3]) * i; else { const h = []; let e = 0; t[4] > t[0] && (e = 1), t[8] > t[3 * e + e] && (e = 2); const a = (e + 1) % 3; const o = (e + 2) % 3; i = g.sqrt(t[3 * e + e] - t[3 * a + a] - t[3 * o + o] + 1), h[e] = 0.5 * fRoot, i = 0.5 / fRoot, this.w = (t[3 * a + o] - t[3 * o + a]) * i, h[a] = (t[3 * a + e] + t[3 * e + a]) * i, h[o] = (t[3 * o + e] + t[3 * e + o]) * i, this.x = h[1], this.y = h[2], this.z = h[3]; } return this; },
    toArray(t, i) { t[i = i || 0] = this.x, t[i + 1] = this.y, t[i + 2] = this.z, t[i + 3] = this.w; },
    fromArray(t, i) { return i = i || 0, this.set(t[i], t[i + 1], t[i + 2], t[i + 3]), this; },
  }), Object.assign(P.prototype, {
    Mat33: !0, set(t, i, s, h, e, a, o, n, r) { const l = this.elements; return l[0] = t, l[1] = i, l[2] = s, l[3] = h, l[4] = e, l[5] = a, l[6] = o, l[7] = n, l[8] = r, this; }, add(t, i) { if (void 0 !== i) return this.addMatrixs(t, i); const s = this.elements; const h = t.elements; return s[0] += h[0], s[1] += h[1], s[2] += h[2], s[3] += h[3], s[4] += h[4], s[5] += h[5], s[6] += h[6], s[7] += h[7], s[8] += h[8], this; }, addMatrixs(t, i) { const s = this.elements; const h = t.elements; const e = i.elements; return s[0] = h[0] + e[0], s[1] = h[1] + e[1], s[2] = h[2] + e[2], s[3] = h[3] + e[3], s[4] = h[4] + e[4], s[5] = h[5] + e[5], s[6] = h[6] + e[6], s[7] = h[7] + e[7], s[8] = h[8] + e[8], this; }, addEqual(t) { const i = this.elements; const s = t.elements; return i[0] += s[0], i[1] += s[1], i[2] += s[2], i[3] += s[3], i[4] += s[4], i[5] += s[5], i[6] += s[6], i[7] += s[7], i[8] += s[8], this; }, sub(t, i) { if (void 0 !== i) return this.subMatrixs(t, i); const s = this.elements; const h = t.elements; return s[0] -= h[0], s[1] -= h[1], s[2] -= h[2], s[3] -= h[3], s[4] -= h[4], s[5] -= h[5], s[6] -= h[6], s[7] -= h[7], s[8] -= h[8], this; }, subMatrixs(t, i) { const s = this.elements; const h = t.elements; const e = i.elements; return s[0] = h[0] - e[0], s[1] = h[1] - e[1], s[2] = h[2] - e[2], s[3] = h[3] - e[3], s[4] = h[4] - e[4], s[5] = h[5] - e[5], s[6] = h[6] - e[6], s[7] = h[7] - e[7], s[8] = h[8] - e[8], this; }, subEqual(t) { const i = this.elements; const s = t.elements; return i[0] -= s[0], i[1] -= s[1], i[2] -= s[2], i[3] -= s[3], i[4] -= s[4], i[5] -= s[5], i[6] -= s[6], i[7] -= s[7], i[8] -= s[8], this; }, scale(t, i) { const s = this.elements; const h = t.elements; return s[0] = h[0] * i, s[1] = h[1] * i, s[2] = h[2] * i, s[3] = h[3] * i, s[4] = h[4] * i, s[5] = h[5] * i, s[6] = h[6] * i, s[7] = h[7] * i, s[8] = h[8] * i, this; }, scaleEqual(t) { const i = this.elements; return i[0] *= t, i[1] *= t, i[2] *= t, i[3] *= t, i[4] *= t, i[5] *= t, i[6] *= t, i[7] *= t, i[8] *= t, this; }, multiplyMatrices(t, i, s) { s && (i = i.clone().transpose()); const h = this.elements; const e = t.elements; const a = i.elements; const o = e[0]; const n = e[3]; const r = e[6]; const l = e[1]; const c = e[4]; const m = e[7]; const p = e[2]; const u = e[5]; const y = e[8]; const x = a[0]; const d = a[3]; const f = a[6]; const b = a[1]; const v = a[4]; const z = a[7]; const N = a[2]; const k = a[5]; const w = a[8]; return h[0] = o * x + l * d + p * f, h[1] = o * b + l * v + p * z, h[2] = o * N + l * k + p * w, h[3] = n * x + c * d + u * f, h[4] = n * b + c * v + u * z, h[5] = n * N + c * k + u * w, h[6] = r * x + m * d + y * f, h[7] = r * b + m * v + y * z, h[8] = r * N + m * k + y * w, this; }, transpose(t) { if (void 0 !== t) { const i = t.elements; return this.set(i[0], i[3], i[6], i[1], i[4], i[7], i[2], i[5], i[8]), this; } const s = this.elements; const h = s[1]; const e = s[2]; const a = s[5]; return s[1] = s[3], s[2] = s[6], s[3] = h, s[5] = s[7], s[6] = e, s[7] = a, this; }, setQuat(t) { const i = this.elements; const s = t.x; const h = t.y; const e = t.z; const a = t.w; const o = s + s; const n = h + h; const r = e + e; const l = s * o; const c = s * n; const m = s * r; const p = h * n; const u = h * r; const y = e * r; const x = a * o; const d = a * n; const f = a * r; return i[0] = 1 - (p + y), i[1] = c - f, i[2] = m + d, i[3] = c + f, i[4] = 1 - (l + y), i[5] = u - x, i[6] = m - d, i[7] = u + x, i[8] = 1 - (l + p), this; }, invert(t) { const i = this.elements; const s = t.elements; const h = s[0]; const e = s[3]; const a = s[6]; const o = s[1]; const n = s[4]; const r = s[7]; const l = s[2]; const c = s[5]; const m = s[8]; const p = m * n - c * r; const u = -m * e + c * a; const y = r * e - n * a; let x = h * p + o * u + l * y; return x === 0 ? (console.log("can't invert matrix, determinant is 0"), this.identity()) : (x = 1 / x, i[0] = p * x, i[1] = (-m * o + l * r) * x, i[2] = (c * o - l * n) * x, i[3] = u * x, i[4] = (m * h - l * a) * x, i[5] = (-c * h + l * e) * x, i[6] = y * x, i[7] = (-r * h + o * a) * x, i[8] = (n * h - o * e) * x, this); }, addOffset(t, i) { const s = i.x; const h = i.y; const e = i.z; const a = this.elements; a[0] += t * (h * h + e * e), a[4] += t * (s * s + e * e), a[8] += t * (s * s + h * h); const o = t * s * h; const n = t * h * e; const r = t * e * s; return a[1] -= o, a[3] -= o, a[2] -= n, a[6] -= n, a[5] -= r, a[7] -= r, this; }, subOffset(t, i) { const s = i.x; const h = i.y; const e = i.z; const a = this.elements; a[0] -= t * (h * h + e * e), a[4] -= t * (s * s + e * e), a[8] -= t * (s * s + h * h); const o = t * s * h; const n = t * h * e; const r = t * e * s; return a[1] += o, a[3] += o, a[2] += n, a[6] += n, a[5] += r, a[7] += r, this; }, multiplyScalar(t) { const i = this.elements; return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= t, i[4] *= t, i[7] *= t, i[2] *= t, i[5] *= t, i[8] *= t, this; }, identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this; }, clone() { return (new P()).fromArray(this.elements); }, copy(t) { for (let i = 0; i < 9; i++) this.elements[i] = t.elements[i]; return this; }, determinant() { const t = this.elements; const i = t[0]; const s = t[1]; const h = t[2]; const e = t[3]; const a = t[4]; const o = t[5]; const n = t[6]; const r = t[7]; const l = t[8]; return i * a * l - i * o * r - s * e * l + s * o * n + h * e * r - h * a * n; }, fromArray(t, i) { void 0 === i && (i = 0); for (let s = 0; s < 9; s++) this.elements[s] = t[s + i]; return this; }, toArray(t, i) { void 0 === t && (t = []), void 0 === i && (i = 0); const s = this.elements; return t[i] = s[0], t[i + 1] = s[1], t[i + 2] = s[2], t[i + 3] = s[3], t[i + 4] = s[4], t[i + 5] = s[5], t[i + 6] = s[6], t[i + 7] = s[7], t[i + 8] = s[8], t; },
  }), Object.assign(T.prototype, {
    AABB: !0, set(t, i, s, h, e, a) { const o = this.elements; return o[0] = t, o[3] = i, o[1] = s, o[4] = h, o[2] = e, o[5] = a, this; }, intersectTest(t) { const i = this.elements; const s = t.elements; return i[0] > s[3] || i[1] > s[4] || i[2] > s[5] || i[3] < s[0] || i[4] < s[1] || i[5] < s[2]; }, intersectTestTwo(t) { const i = this.elements; const s = t.elements; return i[0] < s[0] || i[1] < s[1] || i[2] < s[2] || i[3] > s[3] || i[4] > s[4] || i[5] > s[5]; }, clone() { return (new this.constructor()).fromArray(this.elements); }, copy(t, i) { const s = i || 0; const h = t.elements; return this.set(h[0] - s, h[3] + s, h[1] - s, h[4] + s, h[2] - s, h[5] + s), this; }, fromArray(t) { return this.elements.set(t), this; }, combine(t, i) { const s = t.elements; const h = i.elements; const e = this.elements; return e[0] = s[0] < h[0] ? s[0] : h[0], e[1] = s[1] < h[1] ? s[1] : h[1], e[2] = s[2] < h[2] ? s[2] : h[2], e[3] = s[3] > h[3] ? s[3] : h[3], e[4] = s[4] > h[4] ? s[4] : h[4], e[5] = s[5] > h[5] ? s[5] : h[5], this; }, surfaceArea() { const t = this.elements; const i = t[3] - t[0]; const s = t[4] - t[1]; const h = t[5] - t[2]; return 2 * (i * (s + h) + s * h); }, intersectsWithPoint(t, i, s) { const h = this.elements; return t >= h[0] && t <= h[3] && i >= h[1] && i <= h[4] && s >= h[2] && s <= h[5]; }, setFromPoints(t) { this.makeEmpty(); for (let i = 0; i < t.length; i++) this.expandByPoint(t[i]); }, makeEmpty() { this.set(-1 / 0, -1 / 0, -1 / 0, 1 / 0, 1 / 0, 1 / 0); }, expandByPoint(t) { const i = this.elements; this.set(g.min(i[0], t.x), g.min(i[1], t.y), g.min(i[2], t.z), g.max(i[3], t.x), g.max(i[4], t.y), g.max(i[5], t.z)); }, expandByScalar(t) { const i = this.elements; i[0] += -t, i[1] += -t, i[2] += -t, i[3] += t, i[4] += t, i[5] += t; },
  }); let A = 0; function j(t) { this.type = p, this.id = A++, this.prev = null, this.next = null, this.proxy = null, this.parent = null, this.contactLink = null, this.numContacts = 0, this.position = new L(), this.rotation = new P(), this.relativePosition = (new L()).copy(t.relativePosition), this.relativeRotation = (new P()).copy(t.relativeRotation), this.aabb = new T(), this.density = t.density, this.friction = t.friction, this.restitution = t.restitution, this.belongsTo = t.belongsTo, this.collidesWith = t.collidesWith; } function C(t, i, s, h) { j.call(this, t), this.type = y, this.width = i, this.height = s, this.depth = h, this.halfWidth = 0.5 * i, this.halfHeight = 0.5 * s, this.halfDepth = 0.5 * h, this.dimentions = new Float32Array(18), this.elements = new Float32Array(24); } function O(t, i) { j.call(this, t), this.type = u, this.radius = i; } function D(t, i, s) { j.call(this, t), this.type = x, this.radius = i, this.height = s, this.halfHeight = 0.5 * s, this.normalDirection = new L(), this.halfDirection = new L(); } function E(t, i) { j.call(this, t), this.type = d, this.normal = new L(0, 1, 0); } function B(t, i) { j.call(this, t), this.type = f; } function F() { this.relativePosition = new L(), this.relativeRotation = new P(), this.friction = 0.2, this.restitution = 0.2, this.density = 1, this.belongsTo = 1, this.collidesWith = 4294967295; } function q(t, i) { i = i || !1, this.axis = t, this.angle = 0, this.lowerLimit = i ? 0 : 1, this.upperLimit = 0, this.motorSpeed = 0, this.maxMotorForce = 0, this.frequency = 0, this.dampingRatio = 0; } function U() { this.parent = null, this.body1 = null, this.body2 = null, this.addedToIsland = !1; } function R(t) { this.prev = null, this.next = null, this.body = null, this.joint = t; } function _(t) { U.call(this), this.scale = 1, this.invScale = 1, this.name = '', this.id = NaN, this.type = b, this.prev = null, this.next = null, this.body1 = t.body1, this.body2 = t.body2, this.localAnchorPoint1 = (new L()).copy(t.localAnchorPoint1), this.localAnchorPoint2 = (new L()).copy(t.localAnchorPoint2), this.relativeAnchorPoint1 = new L(), this.relativeAnchorPoint2 = new L(), this.anchorPoint1 = new L(), this.anchorPoint2 = new L(), this.allowCollision = t.allowCollision, this.b1Link = new R(this), this.b2Link = new R(this); } function J(t) { this.m1 = NaN, this.m2 = NaN, this.ii1 = null, this.ii2 = null, this.dd = null, this.r1x = NaN, this.r1y = NaN, this.r1z = NaN, this.r2x = NaN, this.r2y = NaN, this.r2z = NaN, this.ax1x = NaN, this.ax1y = NaN, this.ax1z = NaN, this.ay1x = NaN, this.ay1y = NaN, this.ay1z = NaN, this.az1x = NaN, this.az1y = NaN, this.az1z = NaN, this.ax2x = NaN, this.ax2y = NaN, this.ax2z = NaN, this.ay2x = NaN, this.ay2y = NaN, this.ay2z = NaN, this.az2x = NaN, this.az2y = NaN, this.az2z = NaN, this.vel = NaN, this.velx = NaN, this.vely = NaN, this.velz = NaN, this.joint = t, this.r1 = t.relativeAnchorPoint1, this.r2 = t.relativeAnchorPoint2, this.p1 = t.anchorPoint1, this.p2 = t.anchorPoint2, this.b1 = t.body1, this.b2 = t.body2, this.l1 = this.b1.linearVelocity, this.l2 = this.b2.linearVelocity, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.impx = 0, this.impy = 0, this.impz = 0; } function W(t, i, s, h) { this.cfm1 = NaN, this.cfm2 = NaN, this.cfm3 = NaN, this.i1e00 = NaN, this.i1e01 = NaN, this.i1e02 = NaN, this.i1e10 = NaN, this.i1e11 = NaN, this.i1e12 = NaN, this.i1e20 = NaN, this.i1e21 = NaN, this.i1e22 = NaN, this.i2e00 = NaN, this.i2e01 = NaN, this.i2e02 = NaN, this.i2e10 = NaN, this.i2e11 = NaN, this.i2e12 = NaN, this.i2e20 = NaN, this.i2e21 = NaN, this.i2e22 = NaN, this.ax1 = NaN, this.ay1 = NaN, this.az1 = NaN, this.ax2 = NaN, this.ay2 = NaN, this.az2 = NaN, this.ax3 = NaN, this.ay3 = NaN, this.az3 = NaN, this.a1x1 = NaN, this.a1y1 = NaN, this.a1z1 = NaN, this.a2x1 = NaN, this.a2y1 = NaN, this.a2z1 = NaN, this.a1x2 = NaN, this.a1y2 = NaN, this.a1z2 = NaN, this.a2x2 = NaN, this.a2y2 = NaN, this.a2z2 = NaN, this.a1x3 = NaN, this.a1y3 = NaN, this.a1z3 = NaN, this.a2x3 = NaN, this.a2y3 = NaN, this.a2z3 = NaN, this.lowerLimit1 = NaN, this.upperLimit1 = NaN, this.limitVelocity1 = NaN, this.limitState1 = 0, this.enableMotor1 = !1, this.motorSpeed1 = NaN, this.maxMotorForce1 = NaN, this.maxMotorImpulse1 = NaN, this.lowerLimit2 = NaN, this.upperLimit2 = NaN, this.limitVelocity2 = NaN, this.limitState2 = 0, this.enableMotor2 = !1, this.motorSpeed2 = NaN, this.maxMotorForce2 = NaN, this.maxMotorImpulse2 = NaN, this.lowerLimit3 = NaN, this.upperLimit3 = NaN, this.limitVelocity3 = NaN, this.limitState3 = 0, this.enableMotor3 = !1, this.motorSpeed3 = NaN, this.maxMotorForce3 = NaN, this.maxMotorImpulse3 = NaN, this.k00 = NaN, this.k01 = NaN, this.k02 = NaN, this.k10 = NaN, this.k11 = NaN, this.k12 = NaN, this.k20 = NaN, this.k21 = NaN, this.k22 = NaN, this.kv00 = NaN, this.kv11 = NaN, this.kv22 = NaN, this.dv00 = NaN, this.dv11 = NaN, this.dv22 = NaN, this.d00 = NaN, this.d01 = NaN, this.d02 = NaN, this.d10 = NaN, this.d11 = NaN, this.d12 = NaN, this.d20 = NaN, this.d21 = NaN, this.d22 = NaN, this.limitMotor1 = i, this.limitMotor2 = s, this.limitMotor3 = h, this.b1 = t.body1, this.b2 = t.body2, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.limitImpulse1 = 0, this.motorImpulse1 = 0, this.limitImpulse2 = 0, this.motorImpulse2 = 0, this.limitImpulse3 = 0, this.motorImpulse3 = 0; } function H(t, i, s) { _.call(this, t), this.type = N, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(); const h = (new P()).setQuat((new S()).setFromUnitVectors(this.localAxis1, this.localAxis2)); this.localAngle1 = (new L()).tangent(this.localAxis1).normalize(), this.localAngle2 = this.localAngle1.clone().applyMatrix3(h, !0), this.ax1 = new L(), this.ax2 = new L(), this.an1 = new L(), this.an2 = new L(), this.tmp = new L(), this.nor = new L(), this.tan = new L(), this.bin = new L(), this.limitMotor = new q(this.nor, !1), this.limitMotor.lowerLimit = i, this.limitMotor.upperLimit = s, this.lc = new J(this), this.r3 = new W(this, this.limitMotor, new q(this.tan, !0), new q(this.bin, !0)); } function Q(t) { _.call(this, t), this.type = z, this.lc = new J(this); } function X(t, i) { this.cfm = NaN, this.m1 = NaN, this.m2 = NaN, this.i1e00 = NaN, this.i1e01 = NaN, this.i1e02 = NaN, this.i1e10 = NaN, this.i1e11 = NaN, this.i1e12 = NaN, this.i1e20 = NaN, this.i1e21 = NaN, this.i1e22 = NaN, this.i2e00 = NaN, this.i2e01 = NaN, this.i2e02 = NaN, this.i2e10 = NaN, this.i2e11 = NaN, this.i2e12 = NaN, this.i2e20 = NaN, this.i2e21 = NaN, this.i2e22 = NaN, this.motorDenom = NaN, this.invMotorDenom = NaN, this.invDenom = NaN, this.ax = NaN, this.ay = NaN, this.az = NaN, this.r1x = NaN, this.r1y = NaN, this.r1z = NaN, this.r2x = NaN, this.r2y = NaN, this.r2z = NaN, this.t1x = NaN, this.t1y = NaN, this.t1z = NaN, this.t2x = NaN, this.t2y = NaN, this.t2z = NaN, this.l1x = NaN, this.l1y = NaN, this.l1z = NaN, this.l2x = NaN, this.l2y = NaN, this.l2z = NaN, this.a1x = NaN, this.a1y = NaN, this.a1z = NaN, this.a2x = NaN, this.a2y = NaN, this.a2z = NaN, this.lowerLimit = NaN, this.upperLimit = NaN, this.limitVelocity = NaN, this.limitState = 0, this.enableMotor = !1, this.motorSpeed = NaN, this.maxMotorForce = NaN, this.maxMotorImpulse = NaN, this.limitMotor = i, this.b1 = t.body1, this.b2 = t.body2, this.p1 = t.anchorPoint1, this.p2 = t.anchorPoint2, this.r1 = t.relativeAnchorPoint1, this.r2 = t.relativeAnchorPoint2, this.l1 = this.b1.linearVelocity, this.l2 = this.b2.linearVelocity, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.limitImpulse = 0, this.motorImpulse = 0; } function Y(t, i, s) { _.call(this, t), this.type = v, this.nor = new L(), this.limitMotor = new q(this.nor, !0), this.limitMotor.lowerLimit = i, this.limitMotor.upperLimit = s, this.t = new X(this, this.limitMotor); } function Z(t, i) { this.joint = t, this.targetOrientation = (new S()).invert(i), this.relativeOrientation = new S(), this.ii1 = null, this.ii2 = null, this.dd = null, this.vel = new L(), this.imp = new L(), this.rn0 = new L(), this.rn1 = new L(), this.rn2 = new L(), this.b1 = t.body1, this.b2 = t.body2, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia; } function K(t, i, s, h) { this.m1 = NaN, this.m2 = NaN, this.i1e00 = NaN, this.i1e01 = NaN, this.i1e02 = NaN, this.i1e10 = NaN, this.i1e11 = NaN, this.i1e12 = NaN, this.i1e20 = NaN, this.i1e21 = NaN, this.i1e22 = NaN, this.i2e00 = NaN, this.i2e01 = NaN, this.i2e02 = NaN, this.i2e10 = NaN, this.i2e11 = NaN, this.i2e12 = NaN, this.i2e20 = NaN, this.i2e21 = NaN, this.i2e22 = NaN, this.ax1 = NaN, this.ay1 = NaN, this.az1 = NaN, this.ax2 = NaN, this.ay2 = NaN, this.az2 = NaN, this.ax3 = NaN, this.ay3 = NaN, this.az3 = NaN, this.r1x = NaN, this.r1y = NaN, this.r1z = NaN, this.r2x = NaN, this.r2y = NaN, this.r2z = NaN, this.t1x1 = NaN, this.t1y1 = NaN, this.t1z1 = NaN, this.t2x1 = NaN, this.t2y1 = NaN, this.t2z1 = NaN, this.l1x1 = NaN, this.l1y1 = NaN, this.l1z1 = NaN, this.l2x1 = NaN, this.l2y1 = NaN, this.l2z1 = NaN, this.a1x1 = NaN, this.a1y1 = NaN, this.a1z1 = NaN, this.a2x1 = NaN, this.a2y1 = NaN, this.a2z1 = NaN, this.t1x2 = NaN, this.t1y2 = NaN, this.t1z2 = NaN, this.t2x2 = NaN, this.t2y2 = NaN, this.t2z2 = NaN, this.l1x2 = NaN, this.l1y2 = NaN, this.l1z2 = NaN, this.l2x2 = NaN, this.l2y2 = NaN, this.l2z2 = NaN, this.a1x2 = NaN, this.a1y2 = NaN, this.a1z2 = NaN, this.a2x2 = NaN, this.a2y2 = NaN, this.a2z2 = NaN, this.t1x3 = NaN, this.t1y3 = NaN, this.t1z3 = NaN, this.t2x3 = NaN, this.t2y3 = NaN, this.t2z3 = NaN, this.l1x3 = NaN, this.l1y3 = NaN, this.l1z3 = NaN, this.l2x3 = NaN, this.l2y3 = NaN, this.l2z3 = NaN, this.a1x3 = NaN, this.a1y3 = NaN, this.a1z3 = NaN, this.a2x3 = NaN, this.a2y3 = NaN, this.a2z3 = NaN, this.lowerLimit1 = NaN, this.upperLimit1 = NaN, this.limitVelocity1 = NaN, this.limitState1 = 0, this.enableMotor1 = !1, this.motorSpeed1 = NaN, this.maxMotorForce1 = NaN, this.maxMotorImpulse1 = NaN, this.lowerLimit2 = NaN, this.upperLimit2 = NaN, this.limitVelocity2 = NaN, this.limitState2 = 0, this.enableMotor2 = !1, this.motorSpeed2 = NaN, this.maxMotorForce2 = NaN, this.maxMotorImpulse2 = NaN, this.lowerLimit3 = NaN, this.upperLimit3 = NaN, this.limitVelocity3 = NaN, this.limitState3 = 0, this.enableMotor3 = !1, this.motorSpeed3 = NaN, this.maxMotorForce3 = NaN, this.maxMotorImpulse3 = NaN, this.k00 = NaN, this.k01 = NaN, this.k02 = NaN, this.k10 = NaN, this.k11 = NaN, this.k12 = NaN, this.k20 = NaN, this.k21 = NaN, this.k22 = NaN, this.kv00 = NaN, this.kv11 = NaN, this.kv22 = NaN, this.dv00 = NaN, this.dv11 = NaN, this.dv22 = NaN, this.d00 = NaN, this.d01 = NaN, this.d02 = NaN, this.d10 = NaN, this.d11 = NaN, this.d12 = NaN, this.d20 = NaN, this.d21 = NaN, this.d22 = NaN, this.limitMotor1 = i, this.limitMotor2 = s, this.limitMotor3 = h, this.b1 = t.body1, this.b2 = t.body2, this.p1 = t.anchorPoint1, this.p2 = t.anchorPoint2, this.r1 = t.relativeAnchorPoint1, this.r2 = t.relativeAnchorPoint2, this.l1 = this.b1.linearVelocity, this.l2 = this.b2.linearVelocity, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.limitImpulse1 = 0, this.motorImpulse1 = 0, this.limitImpulse2 = 0, this.motorImpulse2 = 0, this.limitImpulse3 = 0, this.motorImpulse3 = 0, this.cfm1 = 0, this.cfm2 = 0, this.cfm3 = 0, this.weight = -1; } function G(t, i, s) { _.call(this, t), this.type = M, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(), this.ax1 = new L(), this.ax2 = new L(), this.nor = new L(), this.tan = new L(), this.bin = new L(), this.ac = new Z(this, (new S()).setFromUnitVectors(this.localAxis1, this.localAxis2)), this.limitMotor = new q(this.nor, !0), this.limitMotor.lowerLimit = i, this.limitMotor.upperLimit = s, this.t3 = new K(this, this.limitMotor, new q(this.tan, !0), new q(this.bin, !0)); } function $(t, i, s) { _.call(this, t), this.type = w, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(); const h = (new P()).setQuat((new S()).setFromUnitVectors(this.localAxis1, this.localAxis2)); this.localAngle1 = (new L()).tangent(this.localAxis1).normalize(), this.localAngle2 = this.localAngle1.clone().applyMatrix3(h, !0), this.ax1 = new L(), this.ax2 = new L(), this.an1 = new L(), this.an2 = new L(), this.tmp = new L(), this.nor = new L(), this.tan = new L(), this.bin = new L(), this.rotationalLimitMotor = new q(this.nor, !1), this.r3 = new W(this, this.rotationalLimitMotor, new q(this.tan, !0), new q(this.bin, !0)), this.translationalLimitMotor = new q(this.nor, !0), this.translationalLimitMotor.lowerLimit = i, this.translationalLimitMotor.upperLimit = s, this.t3 = new K(this, this.translationalLimitMotor, new q(this.tan, !0), new q(this.bin, !0)); } function tt(t) { _.call(this, t), this.type = k, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(), this.localAngle1 = new L(), this.localAngle2 = new L(); const i = g.dotVectors(this.localAxis1, this.localAxis2); if (i > -1 && i < 1) this.localAngle1.set(this.localAxis2.x - i * this.localAxis1.x, this.localAxis2.y - i * this.localAxis1.y, this.localAxis2.z - i * this.localAxis1.z).normalize(), this.localAngle2.set(this.localAxis1.x - i * this.localAxis2.x, this.localAxis1.y - i * this.localAxis2.y, this.localAxis1.z - i * this.localAxis2.z).normalize(); else { const s = (new P()).setQuat((new S()).setFromUnitVectors(this.localAxis1, this.localAxis2)); this.localAngle1.tangent(this.localAxis1).normalize(), this.localAngle2 = this.localAngle1.clone().applyMatrix3(s, !0); } this.ax1 = new L(), this.ax2 = new L(), this.an1 = new L(), this.an2 = new L(), this.tmp = new L(), this.nor = new L(), this.tan = new L(), this.bin = new L(), this.translationalLimitMotor = new q(this.tan, !0), this.translationalLimitMotor.frequency = 8, this.translationalLimitMotor.dampingRatio = 1, this.rotationalLimitMotor1 = new q(this.tan, !1), this.rotationalLimitMotor2 = new q(this.bin, !1), this.t3 = new K(this, new q(this.nor, !0), this.translationalLimitMotor, new q(this.bin, !0)), this.t3.weight = 1, this.r3 = new W(this, new q(this.nor, !0), this.rotationalLimitMotor1, this.rotationalLimitMotor2); } function it() { this.scale = 1, this.invScale = 1, this.body1 = null, this.body2 = null, this.localAnchorPoint1 = new L(), this.localAnchorPoint2 = new L(), this.localAxis1 = new L(), this.localAxis2 = new L(), this.allowCollision = !1; } function st() { this.mass = 0, this.inertia = new P(); } function ht(t) { this.prev = null, this.next = null, this.shape = null, this.body = null, this.contact = t; } function et() { this.lp1X = NaN, this.lp1Y = NaN, this.lp1Z = NaN, this.lp2X = NaN, this.lp2Y = NaN, this.lp2Z = NaN, this.impulse = NaN; } function at() { this.warmStarted = !1, this.position = new L(), this.localPoint1 = new L(), this.localPoint2 = new L(), this.normal = new L(), this.tangent = new L(), this.binormal = new L(), this.normalImpulse = 0, this.tangentImpulse = 0, this.binormalImpulse = 0, this.normalDenominator = 0, this.tangentDenominator = 0, this.binormalDenominator = 0, this.penetration = 0; } function ot() { this.body1 = null, this.body2 = null, this.numPoints = 0, this.points = [new at(), new at(), new at(), new at()]; } function nt() { this.nor = new L(), this.tan = new L(), this.bin = new L(), this.norU1 = new L(), this.tanU1 = new L(), this.binU1 = new L(), this.norU2 = new L(), this.tanU2 = new L(), this.binU2 = new L(), this.norT1 = new L(), this.tanT1 = new L(), this.binT1 = new L(), this.norT2 = new L(), this.tanT2 = new L(), this.binT2 = new L(), this.norTU1 = new L(), this.tanTU1 = new L(), this.binTU1 = new L(), this.norTU2 = new L(), this.tanTU2 = new L(), this.binTU2 = new L(), this.norImp = 0, this.tanImp = 0, this.binImp = 0, this.norDen = 0, this.tanDen = 0, this.binDen = 0, this.norTar = 0, this.next = null, this.last = !1; } function rt(t) { U.call(this), this.manifold = t, this.restitution = NaN, this.friction = NaN, this.p1 = null, this.p2 = null, this.lv1 = null, this.lv2 = null, this.av1 = null, this.av2 = null, this.i1 = null, this.i2 = null, this.tmp = new L(), this.tmpC1 = new L(), this.tmpC2 = new L(), this.tmpP1 = new L(), this.tmpP2 = new L(), this.tmplv1 = new L(), this.tmplv2 = new L(), this.tmpav1 = new L(), this.tmpav2 = new L(), this.m1 = NaN, this.m2 = NaN, this.num = 0, this.ps = t.points, this.cs = new nt(), this.cs.next = new nt(), this.cs.next.next = new nt(), this.cs.next.next.next = new nt(); } function lt() { this.shape1 = null, this.shape2 = null, this.body1 = null, this.body2 = null, this.prev = null, this.next = null, this.persisting = !1, this.sleeping = !1, this.detector = null, this.constraint = null, this.touching = !1, this.close = !1, this.dist = g.INF, this.b1Link = new ht(this), this.b2Link = new ht(this), this.s1Link = new ht(this), this.s2Link = new ht(this), this.manifold = new ot(), this.buffer = [new et(), new et(), new et(), new et()], this.points = this.manifold.points, this.constraint = new rt(this.manifold); } function ct(t, i) { this.position = t || new L(), this.orientation = i || new S(), this.scale = 1, this.invScale = 1, this.mesh = null, this.id = NaN, this.name = '', this.prev = null, this.next = null, this.type = m, this.massInfo = new st(), this.newPosition = new L(), this.controlPos = !1, this.newOrientation = new S(), this.newRotation = new L(), this.currentRotation = new L(), this.controlRot = !1, this.controlRotInTime = !1, this.quaternion = new S(), this.pos = new L(), this.linearVelocity = new L(), this.angularVelocity = new L(), this.parent = null, this.contactLink = null, this.numContacts = 0, this.shapes = null, this.numShapes = 0, this.jointLink = null, this.numJoints = 0, this.sleepPosition = new L(), this.sleepOrientation = new S(), this.isStatic = !1, this.isDynamic = !1, this.isKinematic = !1, this.rotation = new P(), this.mass = 0, this.inverseMass = 0, this.inverseInertia = new P(), this.localInertia = new P(), this.inverseLocalInertia = new P(), this.tmpInertia = new P(), this.addedToIsland = !1, this.allowSleep = !0, this.sleepTime = 0, this.sleeping = !1; } function mt(t, i) { this.shape1 = t || null, this.shape2 = i || null; } function pt() { this.types = n, this.numPairChecks = 0, this.numPairs = 0, this.pairs = []; }Object.assign(j.prototype, { Shape: !0, calculateMassInfo(t) { I('Shape', 'Inheritance error.'); }, updateProxy() { I('Shape', 'Inheritance error.'); } }), C.prototype = Object.assign(Object.create(j.prototype), { constructor: C, calculateMassInfo(t) { const i = this.width * this.height * this.depth * this.density; t.mass = i, t.inertia.set(i * (this.height * this.height + this.depth * this.depth) * (1 / 12), 0, 0, 0, i * (this.width * this.width + this.depth * this.depth) * (1 / 12), 0, 0, 0, i * (this.width * this.width + this.height * this.height) * (1 / 12)); }, updateProxy() { const t = this.rotation.elements; const i = this.dimentions; i[0] = t[0], i[1] = t[3], i[2] = t[6], i[3] = t[1], i[4] = t[4], i[5] = t[7], i[6] = t[2], i[7] = t[5], i[8] = t[8], i[9] = t[0] * this.halfWidth, i[10] = t[3] * this.halfWidth, i[11] = t[6] * this.halfWidth, i[12] = t[1] * this.halfHeight, i[13] = t[4] * this.halfHeight, i[14] = t[7] * this.halfHeight, i[15] = t[2] * this.halfDepth, i[16] = t[5] * this.halfDepth, i[17] = t[8] * this.halfDepth; const s = i[9]; const h = i[10]; const e = i[11]; const a = i[12]; const o = i[13]; const n = i[14]; const r = i[15]; const l = i[16]; const c = i[17]; const m = this.position.x; const p = this.position.y; const u = this.position.z; const y = this.elements; y[0] = m + s + a + r, y[1] = p + h + o + l, y[2] = u + e + n + c, y[3] = m + s + a - r, y[4] = p + h + o - l, y[5] = u + e + n - c, y[6] = m + s - a + r, y[7] = p + h - o + l, y[8] = u + e - n + c, y[9] = m + s - a - r, y[10] = p + h - o - l, y[11] = u + e - n - c, y[12] = m - s + a + r, y[13] = p - h + o + l, y[14] = u - e + n + c, y[15] = m - s + a - r, y[16] = p - h + o - l, y[17] = u - e + n - c, y[18] = m - s - a + r, y[19] = p - h - o + l, y[20] = u - e - n + c, y[21] = m - s - a - r, y[22] = p - h - o - l, y[23] = u - e - n - c; let x = i[9] < 0 ? -i[9] : i[9]; let d = i[10] < 0 ? -i[10] : i[10]; let f = i[11] < 0 ? -i[11] : i[11]; x = i[12] < 0 ? x - i[12] : x + i[12], d = i[13] < 0 ? d - i[13] : d + i[13], f = i[14] < 0 ? f - i[14] : f + i[14], x = i[15] < 0 ? x - i[15] : x + i[15], d = i[16] < 0 ? d - i[16] : d + i[16], f = i[17] < 0 ? f - i[17] : f + i[17]; const b = 0.005; this.aabb.set(this.position.x - x - b, this.position.x + x + b, this.position.y - d - b, this.position.y + d + b, this.position.z - f - b, this.position.z + f + b), this.proxy != null && this.proxy.update(); } }), O.prototype = Object.assign(Object.create(j.prototype), {
    constructor: O, volume() { return g.PI * this.radius * 1.333333; }, calculateMassInfo(t) { const i = this.volume() * this.radius * this.radius * this.density; t.mass = i; const s = i * this.radius * this.radius * 0.4; t.inertia.set(s, 0, 0, 0, s, 0, 0, 0, s); }, updateProxy() { const t = 0.005; this.aabb.set(this.position.x - this.radius - t, this.position.x + this.radius + t, this.position.y - this.radius - t, this.position.y + this.radius + t, this.position.z - this.radius - t, this.position.z + this.radius + t), this.proxy != null && this.proxy.update(); },
  }), D.prototype = Object.assign(Object.create(j.prototype), { constructor: D, calculateMassInfo(t) { const i = this.radius * this.radius; const s = g.PI * i * this.height * this.density; const h = (0.25 * i + 0.0833 * this.height * this.height) * s; const e = 0.5 * i; t.mass = s, t.inertia.set(h, 0, 0, 0, e, 0, 0, 0, h); }, updateProxy() { let t; let i; let s; let h; let e; let a; let o; let n; let r; let l; let c; const m = this.rotation.elements; e = m[1] * m[1], a = m[4] * m[4], o = m[7] * m[7], this.normalDirection.set(m[1], m[4], m[7]), this.halfDirection.scale(this.normalDirection, this.halfHeight), i = 1 - e, (t = g.sqrt(i * i + e * a + e * o)) > 0 && (t = this.radius / t), i *= t, s = 1 - a, (t = g.sqrt(a * e + s * s + a * o)) > 0 && (t = this.radius / t), s *= t, h = 1 - o, (t = g.sqrt(o * e + o * a + h * h)) > 0 && (t = this.radius / t), h *= t, n = this.halfDirection.x < 0 ? -this.halfDirection.x : this.halfDirection.x, r = this.halfDirection.y < 0 ? -this.halfDirection.y : this.halfDirection.y, l = this.halfDirection.z < 0 ? -this.halfDirection.z : this.halfDirection.z, n = i < 0 ? n - i : n + i, r = s < 0 ? r - s : r + s, l = h < 0 ? l - h : l + h, c = 0.005, this.aabb.set(this.position.x - n - c, this.position.x + n + c, this.position.y - r - c, this.position.y + r + c, this.position.z - l - c, this.position.z + l + c), this.proxy != null && this.proxy.update(); } }), E.prototype = Object.assign(Object.create(j.prototype), {
    constructor: E, volume() { return Number.MAX_VALUE; }, calculateMassInfo(t) { t.mass = this.density; t.inertia.set(1, 0, 0, 0, 1, 0, 0, 0, 1); }, updateProxy() { const t = 0.005; const i = -g.INF; const s = g.INF; const h = this.normal; this.aabb.set(h.x === -1 ? this.position.x - t : i, h.x === 1 ? this.position.x + t : s, h.y === -1 ? this.position.y - t : i, h.y === 1 ? this.position.y + t : s, h.z === -1 ? this.position.z - t : i, h.z === 1 ? this.position.z + t : s), this.proxy != null && this.proxy.update(); },
  }), B.prototype = Object.assign(Object.create(j.prototype), {
    constructor: B, volume() { return Number.MAX_VALUE; }, calculateMassInfo(t) { t.inertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0); }, updateProxy() { this.aabb.set(this.position.x - 0, this.position.x + 0, this.position.y - 0, this.position.y + 0, this.position.z - 0, this.position.z + 0), this.proxy != null && this.proxy.update(); },
  }), Object.assign(q.prototype, {
    LimitMotor: !0, setLimit(t, i) { this.lowerLimit = t, this.upperLimit = i; }, setMotor(t, i) { this.motorSpeed = t, this.maxMotorForce = i; }, setSpring(t, i) { this.frequency = t, this.dampingRatio = i; },
  }), Object.assign(U.prototype, {
    Constraint: !0, preSolve(t, i) { I('Constraint', 'Inheritance error.'); }, solve() { I('Constraint', 'Inheritance error.'); }, postSolve() { I('Constraint', 'Inheritance error.'); },
  }), _.prototype = Object.assign(Object.create(U.prototype), {
    constructor: _, setId(t) { this.id = i; }, setParent(t) { this.parent = t, this.scale = this.parent.scale, this.invScale = this.parent.invScale, this.id = this.parent.numJoints, this.name || (this.name = `J${this.id}`); }, updateAnchorPoints() { this.relativeAnchorPoint1.copy(this.localAnchorPoint1).applyMatrix3(this.body1.rotation, !0), this.relativeAnchorPoint2.copy(this.localAnchorPoint2).applyMatrix3(this.body2.rotation, !0), this.anchorPoint1.add(this.relativeAnchorPoint1, this.body1.position), this.anchorPoint2.add(this.relativeAnchorPoint2, this.body2.position); }, attach(t) { this.b1Link.body = this.body2, this.b2Link.body = this.body1, t ? (this.body1.jointLink.push(this.b1Link), this.body2.jointLink.push(this.b2Link)) : (this.body1.jointLink != null ? (this.b1Link.next = this.body1.jointLink).prev = this.b1Link : this.b1Link.next = null, this.body1.jointLink = this.b1Link, this.body1.numJoints++, this.body2.jointLink != null ? (this.b2Link.next = this.body2.jointLink).prev = this.b2Link : this.b2Link.next = null, this.body2.jointLink = this.b2Link, this.body2.numJoints++); }, detach(t) { if (t) this.body1.jointLink.splice(this.body1.jointLink.indexOf(this.b1Link), 1), this.body2.jointLink.splice(this.body2.jointLink.indexOf(this.b2Link), 1); else { let i = this.b1Link.prev; let s = this.b1Link.next; i != null && (i.next = s), s != null && (s.prev = i), this.body1.jointLink == this.b1Link && (this.body1.jointLink = s), this.b1Link.prev = null, this.b1Link.next = null, this.b1Link.body = null, this.body1.numJoints--, i = this.b2Link.prev, s = this.b2Link.next, i != null && (i.next = s), s != null && (s.prev = i), this.body2.jointLink == this.b2Link && (this.body2.jointLink = s), this.b2Link.prev = null, this.b2Link.next = null, this.b2Link.body = null, this.body2.numJoints--; } this.b1Link.body = null, this.b2Link.body = null; }, awake() { this.body1.awake(), this.body2.awake(); }, preSolve(t, i) {}, solve() {}, postSolve() {}, remove() { this.dispose(); }, dispose() { this.parent.removeJoint(this); }, getPosition() { return [(new L()).scale(this.anchorPoint1, this.scale), (new L()).scale(this.anchorPoint2, this.scale)]; },
  }), Object.assign(J.prototype, { LinearConstraint: !0, preSolve(t, i) { this.r1x = this.r1.x, this.r1y = this.r1.y, this.r1z = this.r1.z, this.r2x = this.r2.x, this.r2y = this.r2.y, this.r2z = this.r2.z, this.m1 = this.b1.inverseMass, this.m2 = this.b2.inverseMass, this.ii1 = this.i1.clone(), this.ii2 = this.i2.clone(); const s = this.ii1.elements; const h = this.ii2.elements; this.ax1x = this.r1z * s[1] + -this.r1y * s[2], this.ax1y = this.r1z * s[4] + -this.r1y * s[5], this.ax1z = this.r1z * s[7] + -this.r1y * s[8], this.ay1x = -this.r1z * s[0] + this.r1x * s[2], this.ay1y = -this.r1z * s[3] + this.r1x * s[5], this.ay1z = -this.r1z * s[6] + this.r1x * s[8], this.az1x = this.r1y * s[0] + -this.r1x * s[1], this.az1y = this.r1y * s[3] + -this.r1x * s[4], this.az1z = this.r1y * s[6] + -this.r1x * s[7], this.ax2x = this.r2z * h[1] + -this.r2y * h[2], this.ax2y = this.r2z * h[4] + -this.r2y * h[5], this.ax2z = this.r2z * h[7] + -this.r2y * h[8], this.ay2x = -this.r2z * h[0] + this.r2x * h[2], this.ay2y = -this.r2z * h[3] + this.r2x * h[5], this.ay2z = -this.r2z * h[6] + this.r2x * h[8], this.az2x = this.r2y * h[0] + -this.r2x * h[1], this.az2y = this.r2y * h[3] + -this.r2x * h[4], this.az2z = this.r2y * h[6] + -this.r2x * h[7]; const e = this.m1 + this.m2; const a = (new P()).set(e, 0, 0, 0, e, 0, 0, 0, e).elements; a[0] += s[4] * this.r1z * this.r1z - (s[7] + s[5]) * this.r1y * this.r1z + s[8] * this.r1y * this.r1y, a[1] += (s[6] * this.r1y + s[5] * this.r1x) * this.r1z - s[3] * this.r1z * this.r1z - s[8] * this.r1x * this.r1y, a[2] += (s[3] * this.r1y - s[4] * this.r1x) * this.r1z - s[6] * this.r1y * this.r1y + s[7] * this.r1x * this.r1y, a[3] += (s[2] * this.r1y + s[7] * this.r1x) * this.r1z - s[1] * this.r1z * this.r1z - s[8] * this.r1x * this.r1y, a[4] += s[0] * this.r1z * this.r1z - (s[6] + s[2]) * this.r1x * this.r1z + s[8] * this.r1x * this.r1x, a[5] += (s[1] * this.r1x - s[0] * this.r1y) * this.r1z - s[7] * this.r1x * this.r1x + s[6] * this.r1x * this.r1y, a[6] += (s[1] * this.r1y - s[4] * this.r1x) * this.r1z - s[2] * this.r1y * this.r1y + s[5] * this.r1x * this.r1y, a[7] += (s[3] * this.r1x - s[0] * this.r1y) * this.r1z - s[5] * this.r1x * this.r1x + s[2] * this.r1x * this.r1y, a[8] += s[0] * this.r1y * this.r1y - (s[3] + s[1]) * this.r1x * this.r1y + s[4] * this.r1x * this.r1x, a[0] += h[4] * this.r2z * this.r2z - (h[7] + h[5]) * this.r2y * this.r2z + h[8] * this.r2y * this.r2y, a[1] += (h[6] * this.r2y + h[5] * this.r2x) * this.r2z - h[3] * this.r2z * this.r2z - h[8] * this.r2x * this.r2y, a[2] += (h[3] * this.r2y - h[4] * this.r2x) * this.r2z - h[6] * this.r2y * this.r2y + h[7] * this.r2x * this.r2y, a[3] += (h[2] * this.r2y + h[7] * this.r2x) * this.r2z - h[1] * this.r2z * this.r2z - h[8] * this.r2x * this.r2y, a[4] += h[0] * this.r2z * this.r2z - (h[6] + h[2]) * this.r2x * this.r2z + h[8] * this.r2x * this.r2x, a[5] += (h[1] * this.r2x - h[0] * this.r2y) * this.r2z - h[7] * this.r2x * this.r2x + h[6] * this.r2x * this.r2y, a[6] += (h[1] * this.r2y - h[4] * this.r2x) * this.r2z - h[2] * this.r2y * this.r2y + h[5] * this.r2x * this.r2y, a[7] += (h[3] * this.r2x - h[0] * this.r2y) * this.r2z - h[5] * this.r2x * this.r2x + h[2] * this.r2x * this.r2y, a[8] += h[0] * this.r2y * this.r2y - (h[3] + h[1]) * this.r2x * this.r2y + h[4] * this.r2x * this.r2x; const o = 1 / (a[0] * (a[4] * a[8] - a[7] * a[5]) + a[3] * (a[7] * a[2] - a[1] * a[8]) + a[6] * (a[1] * a[5] - a[4] * a[2])); this.dd = (new P()).set(a[4] * a[8] - a[5] * a[7], a[2] * a[7] - a[1] * a[8], a[1] * a[5] - a[2] * a[4], a[5] * a[6] - a[3] * a[8], a[0] * a[8] - a[2] * a[6], a[2] * a[3] - a[0] * a[5], a[3] * a[7] - a[4] * a[6], a[1] * a[6] - a[0] * a[7], a[0] * a[4] - a[1] * a[3]).scaleEqual(o), this.velx = this.p2.x - this.p1.x, this.vely = this.p2.y - this.p1.y, this.velz = this.p2.z - this.p1.z; let n = g.sqrt(this.velx * this.velx + this.vely * this.vely + this.velz * this.velz); n > 0.005 ? (n = (0.005 - n) / n * i * 0.05, this.velx *= n, this.vely *= n, this.velz *= n) : (this.velx = 0, this.vely = 0, this.velz = 0), this.impx *= 0.95, this.impy *= 0.95, this.impz *= 0.95, this.l1.x += this.impx * this.m1, this.l1.y += this.impy * this.m1, this.l1.z += this.impz * this.m1, this.a1.x += this.impx * this.ax1x + this.impy * this.ay1x + this.impz * this.az1x, this.a1.y += this.impx * this.ax1y + this.impy * this.ay1y + this.impz * this.az1y, this.a1.z += this.impx * this.ax1z + this.impy * this.ay1z + this.impz * this.az1z, this.l2.x -= this.impx * this.m2, this.l2.y -= this.impy * this.m2, this.l2.z -= this.impz * this.m2, this.a2.x -= this.impx * this.ax2x + this.impy * this.ay2x + this.impz * this.az2x, this.a2.y -= this.impx * this.ax2y + this.impy * this.ay2y + this.impz * this.az2y, this.a2.z -= this.impx * this.ax2z + this.impy * this.ay2z + this.impz * this.az2z; }, solve() { const t = this.dd.elements; const i = this.l2.x - this.l1.x + this.a2.y * this.r2z - this.a2.z * this.r2y - this.a1.y * this.r1z + this.a1.z * this.r1y - this.velx; const s = this.l2.y - this.l1.y + this.a2.z * this.r2x - this.a2.x * this.r2z - this.a1.z * this.r1x + this.a1.x * this.r1z - this.vely; const h = this.l2.z - this.l1.z + this.a2.x * this.r2y - this.a2.y * this.r2x - this.a1.x * this.r1y + this.a1.y * this.r1x - this.velz; const e = i * t[0] + s * t[1] + h * t[2]; const a = i * t[3] + s * t[4] + h * t[5]; const o = i * t[6] + s * t[7] + h * t[8]; this.impx += e, this.impy += a, this.impz += o, this.l1.x += e * this.m1, this.l1.y += a * this.m1, this.l1.z += o * this.m1, this.a1.x += e * this.ax1x + a * this.ay1x + o * this.az1x, this.a1.y += e * this.ax1y + a * this.ay1y + o * this.az1y, this.a1.z += e * this.ax1z + a * this.ay1z + o * this.az1z, this.l2.x -= e * this.m2, this.l2.y -= a * this.m2, this.l2.z -= o * this.m2, this.a2.x -= e * this.ax2x + a * this.ay2x + o * this.az2x, this.a2.y -= e * this.ax2y + a * this.ay2y + o * this.az2y, this.a2.z -= e * this.ax2z + a * this.ay2z + o * this.az2z; } }), Object.assign(W.prototype, {
    Rotational3Constraint: !0, preSolve(t, i) { this.ax1 = this.limitMotor1.axis.x, this.ay1 = this.limitMotor1.axis.y, this.az1 = this.limitMotor1.axis.z, this.ax2 = this.limitMotor2.axis.x, this.ay2 = this.limitMotor2.axis.y, this.az2 = this.limitMotor2.axis.z, this.ax3 = this.limitMotor3.axis.x, this.ay3 = this.limitMotor3.axis.y, this.az3 = this.limitMotor3.axis.z, this.lowerLimit1 = this.limitMotor1.lowerLimit, this.upperLimit1 = this.limitMotor1.upperLimit, this.motorSpeed1 = this.limitMotor1.motorSpeed, this.maxMotorForce1 = this.limitMotor1.maxMotorForce, this.enableMotor1 = this.maxMotorForce1 > 0, this.lowerLimit2 = this.limitMotor2.lowerLimit, this.upperLimit2 = this.limitMotor2.upperLimit, this.motorSpeed2 = this.limitMotor2.motorSpeed, this.maxMotorForce2 = this.limitMotor2.maxMotorForce, this.enableMotor2 = this.maxMotorForce2 > 0, this.lowerLimit3 = this.limitMotor3.lowerLimit, this.upperLimit3 = this.limitMotor3.upperLimit, this.motorSpeed3 = this.limitMotor3.motorSpeed, this.maxMotorForce3 = this.limitMotor3.maxMotorForce, this.enableMotor3 = this.maxMotorForce3 > 0; const s = this.i1.elements; const h = this.i2.elements; this.i1e00 = s[0], this.i1e01 = s[1], this.i1e02 = s[2], this.i1e10 = s[3], this.i1e11 = s[4], this.i1e12 = s[5], this.i1e20 = s[6], this.i1e21 = s[7], this.i1e22 = s[8], this.i2e00 = h[0], this.i2e01 = h[1], this.i2e02 = h[2], this.i2e10 = h[3], this.i2e11 = h[4], this.i2e12 = h[5], this.i2e20 = h[6], this.i2e21 = h[7], this.i2e22 = h[8]; const e = this.limitMotor1.frequency; const a = this.limitMotor2.frequency; const o = this.limitMotor3.frequency; const n = e > 0; const r = a > 0; const l = o > 0; const c = this.lowerLimit1 <= this.upperLimit1; const m = this.lowerLimit2 <= this.upperLimit2; const p = this.lowerLimit3 <= this.upperLimit3; const u = this.limitMotor1.angle; c ? (this.lowerLimit1 == this.upperLimit1 ? (this.limitState1 != 0 && (this.limitState1 = 0, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - u) : u < this.lowerLimit1 ? (this.limitState1 != -1 && (this.limitState1 = -1, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - u) : u > this.upperLimit1 ? (this.limitState1 != 1 && (this.limitState1 = 1, this.limitImpulse1 = 0), this.limitVelocity1 = this.upperLimit1 - u) : (this.limitState1 = 2, this.limitImpulse1 = 0, this.limitVelocity1 = 0), n || (this.limitVelocity1 > 0.02 ? this.limitVelocity1 -= 0.02 : this.limitVelocity1 < -0.02 ? this.limitVelocity1 += 0.02 : this.limitVelocity1 = 0)) : (this.limitState1 = 2, this.limitImpulse1 = 0); const y = this.limitMotor2.angle; m ? (this.lowerLimit2 == this.upperLimit2 ? (this.limitState2 != 0 && (this.limitState2 = 0, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - y) : y < this.lowerLimit2 ? (this.limitState2 != -1 && (this.limitState2 = -1, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - y) : y > this.upperLimit2 ? (this.limitState2 != 1 && (this.limitState2 = 1, this.limitImpulse2 = 0), this.limitVelocity2 = this.upperLimit2 - y) : (this.limitState2 = 2, this.limitImpulse2 = 0, this.limitVelocity2 = 0), r || (this.limitVelocity2 > 0.02 ? this.limitVelocity2 -= 0.02 : this.limitVelocity2 < -0.02 ? this.limitVelocity2 += 0.02 : this.limitVelocity2 = 0)) : (this.limitState2 = 2, this.limitImpulse2 = 0); const x = this.limitMotor3.angle; if (p ? (this.lowerLimit3 == this.upperLimit3 ? (this.limitState3 != 0 && (this.limitState3 = 0, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - x) : x < this.lowerLimit3 ? (this.limitState3 != -1 && (this.limitState3 = -1, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - x) : x > this.upperLimit3 ? (this.limitState3 != 1 && (this.limitState3 = 1, this.limitImpulse3 = 0), this.limitVelocity3 = this.upperLimit3 - x) : (this.limitState3 = 2, this.limitImpulse3 = 0, this.limitVelocity3 = 0), l || (this.limitVelocity3 > 0.02 ? this.limitVelocity3 -= 0.02 : this.limitVelocity3 < -0.02 ? this.limitVelocity3 += 0.02 : this.limitVelocity3 = 0)) : (this.limitState3 = 2, this.limitImpulse3 = 0), this.enableMotor1 && (this.limitState1 != 0 || n) ? this.maxMotorImpulse1 = this.maxMotorForce1 * t : (this.motorImpulse1 = 0, this.maxMotorImpulse1 = 0), this.enableMotor2 && (this.limitState2 != 0 || r) ? this.maxMotorImpulse2 = this.maxMotorForce2 * t : (this.motorImpulse2 = 0, this.maxMotorImpulse2 = 0), this.enableMotor3 && (this.limitState3 != 0 || l) ? this.maxMotorImpulse3 = this.maxMotorForce3 * t : (this.motorImpulse3 = 0, this.maxMotorImpulse3 = 0), this.a1x1 = this.ax1 * this.i1e00 + this.ay1 * this.i1e01 + this.az1 * this.i1e02, this.a1y1 = this.ax1 * this.i1e10 + this.ay1 * this.i1e11 + this.az1 * this.i1e12, this.a1z1 = this.ax1 * this.i1e20 + this.ay1 * this.i1e21 + this.az1 * this.i1e22, this.a2x1 = this.ax1 * this.i2e00 + this.ay1 * this.i2e01 + this.az1 * this.i2e02, this.a2y1 = this.ax1 * this.i2e10 + this.ay1 * this.i2e11 + this.az1 * this.i2e12, this.a2z1 = this.ax1 * this.i2e20 + this.ay1 * this.i2e21 + this.az1 * this.i2e22, this.a1x2 = this.ax2 * this.i1e00 + this.ay2 * this.i1e01 + this.az2 * this.i1e02, this.a1y2 = this.ax2 * this.i1e10 + this.ay2 * this.i1e11 + this.az2 * this.i1e12, this.a1z2 = this.ax2 * this.i1e20 + this.ay2 * this.i1e21 + this.az2 * this.i1e22, this.a2x2 = this.ax2 * this.i2e00 + this.ay2 * this.i2e01 + this.az2 * this.i2e02, this.a2y2 = this.ax2 * this.i2e10 + this.ay2 * this.i2e11 + this.az2 * this.i2e12, this.a2z2 = this.ax2 * this.i2e20 + this.ay2 * this.i2e21 + this.az2 * this.i2e22, this.a1x3 = this.ax3 * this.i1e00 + this.ay3 * this.i1e01 + this.az3 * this.i1e02, this.a1y3 = this.ax3 * this.i1e10 + this.ay3 * this.i1e11 + this.az3 * this.i1e12, this.a1z3 = this.ax3 * this.i1e20 + this.ay3 * this.i1e21 + this.az3 * this.i1e22, this.a2x3 = this.ax3 * this.i2e00 + this.ay3 * this.i2e01 + this.az3 * this.i2e02, this.a2y3 = this.ax3 * this.i2e10 + this.ay3 * this.i2e11 + this.az3 * this.i2e12, this.a2z3 = this.ax3 * this.i2e20 + this.ay3 * this.i2e21 + this.az3 * this.i2e22, this.k00 = this.ax1 * (this.a1x1 + this.a2x1) + this.ay1 * (this.a1y1 + this.a2y1) + this.az1 * (this.a1z1 + this.a2z1), this.k01 = this.ax1 * (this.a1x2 + this.a2x2) + this.ay1 * (this.a1y2 + this.a2y2) + this.az1 * (this.a1z2 + this.a2z2), this.k02 = this.ax1 * (this.a1x3 + this.a2x3) + this.ay1 * (this.a1y3 + this.a2y3) + this.az1 * (this.a1z3 + this.a2z3), this.k10 = this.ax2 * (this.a1x1 + this.a2x1) + this.ay2 * (this.a1y1 + this.a2y1) + this.az2 * (this.a1z1 + this.a2z1), this.k11 = this.ax2 * (this.a1x2 + this.a2x2) + this.ay2 * (this.a1y2 + this.a2y2) + this.az2 * (this.a1z2 + this.a2z2), this.k12 = this.ax2 * (this.a1x3 + this.a2x3) + this.ay2 * (this.a1y3 + this.a2y3) + this.az2 * (this.a1z3 + this.a2z3), this.k20 = this.ax3 * (this.a1x1 + this.a2x1) + this.ay3 * (this.a1y1 + this.a2y1) + this.az3 * (this.a1z1 + this.a2z1), this.k21 = this.ax3 * (this.a1x2 + this.a2x2) + this.ay3 * (this.a1y2 + this.a2y2) + this.az3 * (this.a1z2 + this.a2z2), this.k22 = this.ax3 * (this.a1x3 + this.a2x3) + this.ay3 * (this.a1y3 + this.a2y3) + this.az3 * (this.a1z3 + this.a2z3), this.kv00 = this.k00, this.kv11 = this.k11, this.kv22 = this.k22, this.dv00 = 1 / this.kv00, this.dv11 = 1 / this.kv11, this.dv22 = 1 / this.kv22, n && this.limitState1 != 2) { var d = 6.2831853 * e; var f = d * d * t; var b = i / (f + 2 * this.limitMotor1.dampingRatio * d); this.cfm1 = this.kv00 * b, this.limitVelocity1 *= f * b; } else this.cfm1 = 0, this.limitVelocity1 *= 0.05 * i; r && this.limitState2 != 2 ? (b = i / ((f = (d = 6.2831853 * a) * d * t) + 2 * this.limitMotor2.dampingRatio * d), this.cfm2 = this.kv11 * b, this.limitVelocity2 *= f * b) : (this.cfm2 = 0, this.limitVelocity2 *= 0.05 * i), l && this.limitState3 != 2 ? (b = i / ((f = (d = 6.2831853 * o) * d * t) + 2 * this.limitMotor3.dampingRatio * d), this.cfm3 = this.kv22 * b, this.limitVelocity3 *= f * b) : (this.cfm3 = 0, this.limitVelocity3 *= 0.05 * i), this.k00 += this.cfm1, this.k11 += this.cfm2, this.k22 += this.cfm3; const v = 1 / (this.k00 * (this.k11 * this.k22 - this.k21 * this.k12) + this.k10 * (this.k21 * this.k02 - this.k01 * this.k22) + this.k20 * (this.k01 * this.k12 - this.k11 * this.k02)); this.d00 = (this.k11 * this.k22 - this.k12 * this.k21) * v, this.d01 = (this.k02 * this.k21 - this.k01 * this.k22) * v, this.d02 = (this.k01 * this.k12 - this.k02 * this.k11) * v, this.d10 = (this.k12 * this.k20 - this.k10 * this.k22) * v, this.d11 = (this.k00 * this.k22 - this.k02 * this.k20) * v, this.d12 = (this.k02 * this.k10 - this.k00 * this.k12) * v, this.d20 = (this.k10 * this.k21 - this.k11 * this.k20) * v, this.d21 = (this.k01 * this.k20 - this.k00 * this.k21) * v, this.d22 = (this.k00 * this.k11 - this.k01 * this.k10) * v, this.limitImpulse1 *= 0.95, this.motorImpulse1 *= 0.95, this.limitImpulse2 *= 0.95, this.motorImpulse2 *= 0.95, this.limitImpulse3 *= 0.95, this.motorImpulse3 *= 0.95; const z = this.limitImpulse1 + this.motorImpulse1; const N = this.limitImpulse2 + this.motorImpulse2; const k = this.limitImpulse3 + this.motorImpulse3; this.a1.x += z * this.a1x1 + N * this.a1x2 + k * this.a1x3, this.a1.y += z * this.a1y1 + N * this.a1y2 + k * this.a1y3, this.a1.z += z * this.a1z1 + N * this.a1z2 + k * this.a1z3, this.a2.x -= z * this.a2x1 + N * this.a2x2 + k * this.a2x3, this.a2.y -= z * this.a2y1 + N * this.a2y2 + k * this.a2y3, this.a2.z -= z * this.a2z1 + N * this.a2z2 + k * this.a2z3; }, solve_() { const t = this.a2.x - this.a1.x; const i = this.a2.y - this.a1.y; const s = this.a2.z - this.a1.z; this.limitVelocity3 = 30; const h = t * this.ax1 + i * this.ay1 + s * this.az1 - this.limitVelocity1; const e = t * this.ax2 + i * this.ay2 + s * this.az2 - this.limitVelocity2; const a = t * this.ax3 + i * this.ay3 + s * this.az3 - this.limitVelocity3; const o = h * this.d00 + e * this.d01 + a * this.d02; const n = h * this.d10 + e * this.d11 + a * this.d12; const r = h * this.d20 + e * this.d21 + a * this.d22; this.limitImpulse1 += o, this.limitImpulse2 += n, this.limitImpulse3 += r, this.a1.x += o * this.a1x1 + n * this.a1x2 + r * this.a1x3, this.a1.y += o * this.a1y1 + n * this.a1y2 + r * this.a1y3, this.a1.z += o * this.a1z1 + n * this.a1z2 + r * this.a1z3, this.a2.x -= o * this.a2x1 + n * this.a2x2 + r * this.a2x3, this.a2.y -= o * this.a2y1 + n * this.a2y2 + r * this.a2y3, this.a2.z -= o * this.a2z1 + n * this.a2z2 + r * this.a2z3; }, solve() { let t = this.a2.x - this.a1.x; let i = this.a2.y - this.a1.y; let s = this.a2.z - this.a1.z; let h = t * this.ax1 + i * this.ay1 + s * this.az1; let e = t * this.ax2 + i * this.ay2 + s * this.az2; let a = t * this.ax3 + i * this.ay3 + s * this.az3; const o = this.motorImpulse1; const n = this.motorImpulse2; const r = this.motorImpulse3; let l = 0; let c = 0; let m = 0; this.enableMotor1 && (l = (h - this.motorSpeed1) * this.dv00, this.motorImpulse1 += l, this.motorImpulse1 > this.maxMotorImpulse1 ? this.motorImpulse1 = this.maxMotorImpulse1 : this.motorImpulse1 < -this.maxMotorImpulse1 && (this.motorImpulse1 = -this.maxMotorImpulse1), l = this.motorImpulse1 - o), this.enableMotor2 && (c = (e - this.motorSpeed2) * this.dv11, this.motorImpulse2 += c, this.motorImpulse2 > this.maxMotorImpulse2 ? this.motorImpulse2 = this.maxMotorImpulse2 : this.motorImpulse2 < -this.maxMotorImpulse2 && (this.motorImpulse2 = -this.maxMotorImpulse2), c = this.motorImpulse2 - n), this.enableMotor3 && (m = (a - this.motorSpeed3) * this.dv22, this.motorImpulse3 += m, this.motorImpulse3 > this.maxMotorImpulse3 ? this.motorImpulse3 = this.maxMotorImpulse3 : this.motorImpulse3 < -this.maxMotorImpulse3 && (this.motorImpulse3 = -this.maxMotorImpulse3), m = this.motorImpulse3 - r), h += l * this.kv00 + c * this.k01 + m * this.k02, e += l * this.k10 + c * this.kv11 + m * this.k12, a += l * this.k20 + c * this.k21 + m * this.kv22, h -= this.limitVelocity1 + this.limitImpulse1 * this.cfm1, e -= this.limitVelocity2 + this.limitImpulse2 * this.cfm2, a -= this.limitVelocity3 + this.limitImpulse3 * this.cfm3; const p = this.limitImpulse1; const u = this.limitImpulse2; const y = this.limitImpulse3; let x = h * this.d00 + e * this.d01 + a * this.d02; let d = h * this.d10 + e * this.d11 + a * this.d12; let f = h * this.d20 + e * this.d21 + a * this.d22; this.limitImpulse1 += x, this.limitImpulse2 += d, this.limitImpulse3 += f; let b; let v = 0; switch ((this.limitState1 == 2 || this.limitImpulse1 * this.limitState1 < 0) && (e += (x = -p) * this.k10, a += x * this.k20, v |= 1), (this.limitState2 == 2 || this.limitImpulse2 * this.limitState2 < 0) && (h += (d = -u) * this.k01, a += d * this.k21, v |= 2), (this.limitState3 == 2 || this.limitImpulse3 * this.limitState3 < 0) && (h += (f = -y) * this.k02, e += f * this.k12, v |= 4), v) { case 1: b = 1 / (this.k11 * this.k22 - this.k12 * this.k21), d = (this.k22 * e + -this.k12 * a) * b, f = (-this.k21 * e + this.k11 * a) * b; break; case 2: b = 1 / (this.k00 * this.k22 - this.k02 * this.k20), x = (this.k22 * h + -this.k02 * a) * b, f = (-this.k20 * h + this.k00 * a) * b; break; case 3: f = a / this.k22; break; case 4: b = 1 / (this.k00 * this.k11 - this.k01 * this.k10), x = (this.k11 * h + -this.k01 * e) * b, d = (-this.k10 * h + this.k00 * e) * b; break; case 5: d = e / this.k11; break; case 6: x = h / this.k00; } this.limitImpulse1 = x + p, this.limitImpulse2 = d + u, this.limitImpulse3 = f + y; const z = l + x; const N = c + d; const k = m + f; this.a1.x += z * this.a1x1 + N * this.a1x2 + k * this.a1x3, this.a1.y += z * this.a1y1 + N * this.a1y2 + k * this.a1y3, this.a1.z += z * this.a1z1 + N * this.a1z2 + k * this.a1z3, this.a2.x -= z * this.a2x1 + N * this.a2x2 + k * this.a2x3, this.a2.y -= z * this.a2y1 + N * this.a2y2 + k * this.a2y3, this.a2.z -= z * this.a2z1 + N * this.a2z2 + k * this.a2z3, t = this.a2.x - this.a1.x, i = this.a2.y - this.a1.y, s = this.a2.z - this.a1.z, e = t * this.ax2 + i * this.ay2 + s * this.az2; },
  }), H.prototype = Object.assign(Object.create(_.prototype), {
    constructor: H, preSolve(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, !0), this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, !0), this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize(), this.tan.tangent(this.nor).normalize(), this.bin.crossVectors(this.nor, this.tan); const s = g.acosClamp(g.dotVectors(this.an1, this.an2)); this.tmp.crossVectors(this.an1, this.an2), g.dotVectors(this.nor, this.tmp) < 0 ? this.limitMotor.angle = -s : this.limitMotor.angle = s, this.tmp.crossVectors(this.ax1, this.ax2), this.r3.limitMotor2.angle = g.dotVectors(this.tan, this.tmp), this.r3.limitMotor3.angle = g.dotVectors(this.bin, this.tmp), this.r3.preSolve(t, i), this.lc.preSolve(t, i); }, solve() { this.r3.solve(), this.lc.solve(); }, postSolve() {},
  }), Q.prototype = Object.assign(Object.create(_.prototype), {
    constructor: Q, preSolve(t, i) { this.updateAnchorPoints(), this.lc.preSolve(t, i); }, solve() { this.lc.solve(); }, postSolve() {},
  }), Object.assign(X.prototype, { TranslationalConstraint: !0, preSolve(t, i) { this.ax = this.limitMotor.axis.x, this.ay = this.limitMotor.axis.y, this.az = this.limitMotor.axis.z, this.lowerLimit = this.limitMotor.lowerLimit, this.upperLimit = this.limitMotor.upperLimit, this.motorSpeed = this.limitMotor.motorSpeed, this.maxMotorForce = this.limitMotor.maxMotorForce, this.enableMotor = this.maxMotorForce > 0, this.m1 = this.b1.inverseMass, this.m2 = this.b2.inverseMass; const s = this.i1.elements; const h = this.i2.elements; this.i1e00 = s[0], this.i1e01 = s[1], this.i1e02 = s[2], this.i1e10 = s[3], this.i1e11 = s[4], this.i1e12 = s[5], this.i1e20 = s[6], this.i1e21 = s[7], this.i1e22 = s[8], this.i2e00 = h[0], this.i2e01 = h[1], this.i2e02 = h[2], this.i2e10 = h[3], this.i2e11 = h[4], this.i2e12 = h[5], this.i2e20 = h[6], this.i2e21 = h[7], this.i2e22 = h[8]; const e = this.p2.x - this.p1.x; const a = this.p2.y - this.p1.y; const o = this.p2.z - this.p1.z; let n = e * this.ax + a * this.ay + o * this.az; const r = this.limitMotor.frequency; let l = r > 0; (l && n > 20 || n < -20) && (l = !1), this.lowerLimit <= this.upperLimit ? (this.lowerLimit == this.upperLimit ? (this.limitState != 0 && (this.limitState = 0, this.limitImpulse = 0), this.limitVelocity = this.lowerLimit - n, l || (n = this.lowerLimit)) : n < this.lowerLimit ? (this.limitState != -1 && (this.limitState = -1, this.limitImpulse = 0), this.limitVelocity = this.lowerLimit - n, l || (n = this.lowerLimit)) : n > this.upperLimit ? (this.limitState != 1 && (this.limitState = 1, this.limitImpulse = 0), this.limitVelocity = this.upperLimit - n, l || (n = this.upperLimit)) : (this.limitState = 2, this.limitImpulse = 0, this.limitVelocity = 0), l || (this.limitVelocity > 0.005 ? this.limitVelocity -= 0.005 : this.limitVelocity < -0.005 ? this.limitVelocity += 0.005 : this.limitVelocity = 0)) : (this.limitState = 2, this.limitImpulse = 0), this.enableMotor && (this.limitState != 0 || l) ? this.maxMotorImpulse = this.maxMotorForce * t : (this.motorImpulse = 0, this.maxMotorImpulse = 0); const c = n * this.ax; const m = n * this.ay; const p = n * this.az; const u = this.m1 / (this.m1 + this.m2); const y = 1 - u; if (this.r1x = this.r1.x + c * u, this.r1y = this.r1.y + m * u, this.r1z = this.r1.z + p * u, this.r2x = this.r2.x - c * y, this.r2y = this.r2.y - m * y, this.r2z = this.r2.z - p * y, this.t1x = this.r1y * this.az - this.r1z * this.ay, this.t1y = this.r1z * this.ax - this.r1x * this.az, this.t1z = this.r1x * this.ay - this.r1y * this.ax, this.t2x = this.r2y * this.az - this.r2z * this.ay, this.t2y = this.r2z * this.ax - this.r2x * this.az, this.t2z = this.r2x * this.ay - this.r2y * this.ax, this.l1x = this.ax * this.m1, this.l1y = this.ay * this.m1, this.l1z = this.az * this.m1, this.l2x = this.ax * this.m2, this.l2y = this.ay * this.m2, this.l2z = this.az * this.m2, this.a1x = this.t1x * this.i1e00 + this.t1y * this.i1e01 + this.t1z * this.i1e02, this.a1y = this.t1x * this.i1e10 + this.t1y * this.i1e11 + this.t1z * this.i1e12, this.a1z = this.t1x * this.i1e20 + this.t1y * this.i1e21 + this.t1z * this.i1e22, this.a2x = this.t2x * this.i2e00 + this.t2y * this.i2e01 + this.t2z * this.i2e02, this.a2y = this.t2x * this.i2e10 + this.t2y * this.i2e11 + this.t2z * this.i2e12, this.a2z = this.t2x * this.i2e20 + this.t2y * this.i2e21 + this.t2z * this.i2e22, this.motorDenom = this.m1 + this.m2 + this.ax * (this.a1y * this.r1z - this.a1z * this.r1y + this.a2y * this.r2z - this.a2z * this.r2y) + this.ay * (this.a1z * this.r1x - this.a1x * this.r1z + this.a2z * this.r2x - this.a2x * this.r2z) + this.az * (this.a1x * this.r1y - this.a1y * this.r1x + this.a2x * this.r2y - this.a2y * this.r2x), this.invMotorDenom = 1 / this.motorDenom, l && this.limitState != 2) { const x = 6.2831853 * r; const d = x * x * t; const f = i / (d + 2 * this.limitMotor.dampingRatio * x); this.cfm = this.motorDenom * f, this.limitVelocity *= d * f; } else this.cfm = 0, this.limitVelocity *= 0.05 * i; this.invDenom = 1 / (this.motorDenom + this.cfm); const b = this.limitImpulse + this.motorImpulse; this.l1.x += b * this.l1x, this.l1.y += b * this.l1y, this.l1.z += b * this.l1z, this.a1.x += b * this.a1x, this.a1.y += b * this.a1y, this.a1.z += b * this.a1z, this.l2.x -= b * this.l2x, this.l2.y -= b * this.l2y, this.l2.z -= b * this.l2z, this.a2.x -= b * this.a2x, this.a2.y -= b * this.a2y, this.a2.z -= b * this.a2z; }, solve() { let t; let i; let s = this.ax * (this.l2.x - this.l1.x) + this.ay * (this.l2.y - this.l1.y) + this.az * (this.l2.z - this.l1.z) + this.t2x * this.a2.x - this.t1x * this.a1.x + this.t2y * this.a2.y - this.t1y * this.a1.y + this.t2z * this.a2.z - this.t1z * this.a1.z; if (this.enableMotor) { t = (s - this.motorSpeed) * this.invMotorDenom; const h = this.motorImpulse; this.motorImpulse += t, this.motorImpulse > this.maxMotorImpulse ? this.motorImpulse = this.maxMotorImpulse : this.motorImpulse < -this.maxMotorImpulse && (this.motorImpulse = -this.maxMotorImpulse), s -= (t = this.motorImpulse - h) * this.motorDenom; } else t = 0; if (this.limitState != 2) { i = (s - this.limitVelocity - this.limitImpulse * this.cfm) * this.invDenom; const e = this.limitImpulse; this.limitImpulse += i, this.limitImpulse * this.limitState < 0 && (this.limitImpulse = 0), i = this.limitImpulse - e; } else i = 0; const a = i + t; this.l1.x += a * this.l1x, this.l1.y += a * this.l1y, this.l1.z += a * this.l1z, this.a1.x += a * this.a1x, this.a1.y += a * this.a1y, this.a1.z += a * this.a1z, this.l2.x -= a * this.l2x, this.l2.y -= a * this.l2y, this.l2.z -= a * this.l2z, this.a2.x -= a * this.a2x, this.a2.y -= a * this.a2y, this.a2.z -= a * this.a2z; } }), Y.prototype = Object.assign(Object.create(_.prototype), {
    constructor: Y, preSolve(t, i) { this.updateAnchorPoints(), this.nor.sub(this.anchorPoint2, this.anchorPoint1).normalize(), this.t.preSolve(t, i); }, solve() { this.t.solve(); }, postSolve() {},
  }), Object.assign(Z.prototype, { AngularConstraint: !0, preSolve(t, i) { let s; let h; let e; this.ii1 = this.i1.clone(), this.ii2 = this.i2.clone(), s = 1 / ((e = (new P()).add(this.ii1, this.ii2).elements)[0] * (e[4] * e[8] - e[7] * e[5]) + e[3] * (e[7] * e[2] - e[1] * e[8]) + e[6] * (e[1] * e[5] - e[4] * e[2])), this.dd = (new P()).set(e[4] * e[8] - e[5] * e[7], e[2] * e[7] - e[1] * e[8], e[1] * e[5] - e[2] * e[4], e[5] * e[6] - e[3] * e[8], e[0] * e[8] - e[2] * e[6], e[2] * e[3] - e[0] * e[5], e[3] * e[7] - e[4] * e[6], e[1] * e[6] - e[0] * e[7], e[0] * e[4] - e[1] * e[3]).multiplyScalar(s), this.relativeOrientation.invert(this.b1.orientation).multiply(this.targetOrientation).multiply(this.b2.orientation), s = 2 * this.relativeOrientation.w, this.vel.copy(this.relativeOrientation).multiplyScalar(s), (h = this.vel.length()) > 0.02 ? (h = (0.02 - h) / h * i * 0.05, this.vel.multiplyScalar(h)) : this.vel.set(0, 0, 0), this.rn1.copy(this.imp).applyMatrix3(this.ii1, !0), this.rn2.copy(this.imp).applyMatrix3(this.ii2, !0), this.a1.add(this.rn1), this.a2.sub(this.rn2); }, solve() { const t = this.a2.clone().sub(this.a1).sub(this.vel); this.rn0.copy(t).applyMatrix3(this.dd, !0), this.rn1.copy(this.rn0).applyMatrix3(this.ii1, !0), this.rn2.copy(this.rn0).applyMatrix3(this.ii2, !0), this.imp.add(this.rn0), this.a1.add(this.rn1), this.a2.sub(this.rn2); } }), Object.assign(K.prototype, { Translational3Constraint: !0, preSolve(t, i) { this.ax1 = this.limitMotor1.axis.x, this.ay1 = this.limitMotor1.axis.y, this.az1 = this.limitMotor1.axis.z, this.ax2 = this.limitMotor2.axis.x, this.ay2 = this.limitMotor2.axis.y, this.az2 = this.limitMotor2.axis.z, this.ax3 = this.limitMotor3.axis.x, this.ay3 = this.limitMotor3.axis.y, this.az3 = this.limitMotor3.axis.z, this.lowerLimit1 = this.limitMotor1.lowerLimit, this.upperLimit1 = this.limitMotor1.upperLimit, this.motorSpeed1 = this.limitMotor1.motorSpeed, this.maxMotorForce1 = this.limitMotor1.maxMotorForce, this.enableMotor1 = this.maxMotorForce1 > 0, this.lowerLimit2 = this.limitMotor2.lowerLimit, this.upperLimit2 = this.limitMotor2.upperLimit, this.motorSpeed2 = this.limitMotor2.motorSpeed, this.maxMotorForce2 = this.limitMotor2.maxMotorForce, this.enableMotor2 = this.maxMotorForce2 > 0, this.lowerLimit3 = this.limitMotor3.lowerLimit, this.upperLimit3 = this.limitMotor3.upperLimit, this.motorSpeed3 = this.limitMotor3.motorSpeed, this.maxMotorForce3 = this.limitMotor3.maxMotorForce, this.enableMotor3 = this.maxMotorForce3 > 0, this.m1 = this.b1.inverseMass, this.m2 = this.b2.inverseMass; const s = this.i1.elements; const h = this.i2.elements; this.i1e00 = s[0], this.i1e01 = s[1], this.i1e02 = s[2], this.i1e10 = s[3], this.i1e11 = s[4], this.i1e12 = s[5], this.i1e20 = s[6], this.i1e21 = s[7], this.i1e22 = s[8], this.i2e00 = h[0], this.i2e01 = h[1], this.i2e02 = h[2], this.i2e10 = h[3], this.i2e11 = h[4], this.i2e12 = h[5], this.i2e20 = h[6], this.i2e21 = h[7], this.i2e22 = h[8]; const e = this.p2.x - this.p1.x; const a = this.p2.y - this.p1.y; const o = this.p2.z - this.p1.z; let n = e * this.ax1 + a * this.ay1 + o * this.az1; let r = e * this.ax2 + a * this.ay2 + o * this.az2; let l = e * this.ax3 + a * this.ay3 + o * this.az3; const c = this.limitMotor1.frequency; const m = this.limitMotor2.frequency; const p = this.limitMotor3.frequency; let u = c > 0; let y = m > 0; let x = p > 0; const d = this.lowerLimit1 <= this.upperLimit1; const f = this.lowerLimit2 <= this.upperLimit2; const b = this.lowerLimit3 <= this.upperLimit3; (u && n > 20 || n < -20) && (u = !1), (y && r > 20 || r < -20) && (y = !1), (x && l > 20 || l < -20) && (x = !1), d ? (this.lowerLimit1 == this.upperLimit1 ? (this.limitState1 != 0 && (this.limitState1 = 0, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - n, u || (n = this.lowerLimit1)) : n < this.lowerLimit1 ? (this.limitState1 != -1 && (this.limitState1 = -1, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - n, u || (n = this.lowerLimit1)) : n > this.upperLimit1 ? (this.limitState1 != 1 && (this.limitState1 = 1, this.limitImpulse1 = 0), this.limitVelocity1 = this.upperLimit1 - n, u || (n = this.upperLimit1)) : (this.limitState1 = 2, this.limitImpulse1 = 0, this.limitVelocity1 = 0), u || (this.limitVelocity1 > 0.005 ? this.limitVelocity1 -= 0.005 : this.limitVelocity1 < -0.005 ? this.limitVelocity1 += 0.005 : this.limitVelocity1 = 0)) : (this.limitState1 = 2, this.limitImpulse1 = 0), f ? (this.lowerLimit2 == this.upperLimit2 ? (this.limitState2 != 0 && (this.limitState2 = 0, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - r, y || (r = this.lowerLimit2)) : r < this.lowerLimit2 ? (this.limitState2 != -1 && (this.limitState2 = -1, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - r, y || (r = this.lowerLimit2)) : r > this.upperLimit2 ? (this.limitState2 != 1 && (this.limitState2 = 1, this.limitImpulse2 = 0), this.limitVelocity2 = this.upperLimit2 - r, y || (r = this.upperLimit2)) : (this.limitState2 = 2, this.limitImpulse2 = 0, this.limitVelocity2 = 0), y || (this.limitVelocity2 > 0.005 ? this.limitVelocity2 -= 0.005 : this.limitVelocity2 < -0.005 ? this.limitVelocity2 += 0.005 : this.limitVelocity2 = 0)) : (this.limitState2 = 2, this.limitImpulse2 = 0), b ? (this.lowerLimit3 == this.upperLimit3 ? (this.limitState3 != 0 && (this.limitState3 = 0, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - l, x || (l = this.lowerLimit3)) : l < this.lowerLimit3 ? (this.limitState3 != -1 && (this.limitState3 = -1, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - l, x || (l = this.lowerLimit3)) : l > this.upperLimit3 ? (this.limitState3 != 1 && (this.limitState3 = 1, this.limitImpulse3 = 0), this.limitVelocity3 = this.upperLimit3 - l, x || (l = this.upperLimit3)) : (this.limitState3 = 2, this.limitImpulse3 = 0, this.limitVelocity3 = 0), x || (this.limitVelocity3 > 0.005 ? this.limitVelocity3 -= 0.005 : this.limitVelocity3 < -0.005 ? this.limitVelocity3 += 0.005 : this.limitVelocity3 = 0)) : (this.limitState3 = 2, this.limitImpulse3 = 0), this.enableMotor1 && (this.limitState1 != 0 || u) ? this.maxMotorImpulse1 = this.maxMotorForce1 * t : (this.motorImpulse1 = 0, this.maxMotorImpulse1 = 0), this.enableMotor2 && (this.limitState2 != 0 || y) ? this.maxMotorImpulse2 = this.maxMotorForce2 * t : (this.motorImpulse2 = 0, this.maxMotorImpulse2 = 0), this.enableMotor3 && (this.limitState3 != 0 || x) ? this.maxMotorImpulse3 = this.maxMotorForce3 * t : (this.motorImpulse3 = 0, this.maxMotorImpulse3 = 0); const v = n * this.ax1 + r * this.ax2 + l * this.ax2; const z = n * this.ay1 + r * this.ay2 + l * this.ay2; const N = n * this.az1 + r * this.az2 + l * this.az2; let k = this.m2 / (this.m1 + this.m2); this.weight >= 0 && (k = this.weight); const w = 1 - k; this.r1x = this.r1.x + v * k, this.r1y = this.r1.y + z * k, this.r1z = this.r1.z + N * k, this.r2x = this.r2.x - v * w, this.r2y = this.r2.y - z * w, this.r2z = this.r2.z - N * w, this.t1x1 = this.r1y * this.az1 - this.r1z * this.ay1, this.t1y1 = this.r1z * this.ax1 - this.r1x * this.az1, this.t1z1 = this.r1x * this.ay1 - this.r1y * this.ax1, this.t2x1 = this.r2y * this.az1 - this.r2z * this.ay1, this.t2y1 = this.r2z * this.ax1 - this.r2x * this.az1, this.t2z1 = this.r2x * this.ay1 - this.r2y * this.ax1, this.l1x1 = this.ax1 * this.m1, this.l1y1 = this.ay1 * this.m1, this.l1z1 = this.az1 * this.m1, this.l2x1 = this.ax1 * this.m2, this.l2y1 = this.ay1 * this.m2, this.l2z1 = this.az1 * this.m2, this.a1x1 = this.t1x1 * this.i1e00 + this.t1y1 * this.i1e01 + this.t1z1 * this.i1e02, this.a1y1 = this.t1x1 * this.i1e10 + this.t1y1 * this.i1e11 + this.t1z1 * this.i1e12, this.a1z1 = this.t1x1 * this.i1e20 + this.t1y1 * this.i1e21 + this.t1z1 * this.i1e22, this.a2x1 = this.t2x1 * this.i2e00 + this.t2y1 * this.i2e01 + this.t2z1 * this.i2e02, this.a2y1 = this.t2x1 * this.i2e10 + this.t2y1 * this.i2e11 + this.t2z1 * this.i2e12, this.a2z1 = this.t2x1 * this.i2e20 + this.t2y1 * this.i2e21 + this.t2z1 * this.i2e22, this.t1x2 = this.r1y * this.az2 - this.r1z * this.ay2, this.t1y2 = this.r1z * this.ax2 - this.r1x * this.az2, this.t1z2 = this.r1x * this.ay2 - this.r1y * this.ax2, this.t2x2 = this.r2y * this.az2 - this.r2z * this.ay2, this.t2y2 = this.r2z * this.ax2 - this.r2x * this.az2, this.t2z2 = this.r2x * this.ay2 - this.r2y * this.ax2, this.l1x2 = this.ax2 * this.m1, this.l1y2 = this.ay2 * this.m1, this.l1z2 = this.az2 * this.m1, this.l2x2 = this.ax2 * this.m2, this.l2y2 = this.ay2 * this.m2, this.l2z2 = this.az2 * this.m2, this.a1x2 = this.t1x2 * this.i1e00 + this.t1y2 * this.i1e01 + this.t1z2 * this.i1e02, this.a1y2 = this.t1x2 * this.i1e10 + this.t1y2 * this.i1e11 + this.t1z2 * this.i1e12, this.a1z2 = this.t1x2 * this.i1e20 + this.t1y2 * this.i1e21 + this.t1z2 * this.i1e22, this.a2x2 = this.t2x2 * this.i2e00 + this.t2y2 * this.i2e01 + this.t2z2 * this.i2e02, this.a2y2 = this.t2x2 * this.i2e10 + this.t2y2 * this.i2e11 + this.t2z2 * this.i2e12, this.a2z2 = this.t2x2 * this.i2e20 + this.t2y2 * this.i2e21 + this.t2z2 * this.i2e22, this.t1x3 = this.r1y * this.az3 - this.r1z * this.ay3, this.t1y3 = this.r1z * this.ax3 - this.r1x * this.az3, this.t1z3 = this.r1x * this.ay3 - this.r1y * this.ax3, this.t2x3 = this.r2y * this.az3 - this.r2z * this.ay3, this.t2y3 = this.r2z * this.ax3 - this.r2x * this.az3, this.t2z3 = this.r2x * this.ay3 - this.r2y * this.ax3, this.l1x3 = this.ax3 * this.m1, this.l1y3 = this.ay3 * this.m1, this.l1z3 = this.az3 * this.m1, this.l2x3 = this.ax3 * this.m2, this.l2y3 = this.ay3 * this.m2, this.l2z3 = this.az3 * this.m2, this.a1x3 = this.t1x3 * this.i1e00 + this.t1y3 * this.i1e01 + this.t1z3 * this.i1e02, this.a1y3 = this.t1x3 * this.i1e10 + this.t1y3 * this.i1e11 + this.t1z3 * this.i1e12, this.a1z3 = this.t1x3 * this.i1e20 + this.t1y3 * this.i1e21 + this.t1z3 * this.i1e22, this.a2x3 = this.t2x3 * this.i2e00 + this.t2y3 * this.i2e01 + this.t2z3 * this.i2e02, this.a2y3 = this.t2x3 * this.i2e10 + this.t2y3 * this.i2e11 + this.t2z3 * this.i2e12, this.a2z3 = this.t2x3 * this.i2e20 + this.t2y3 * this.i2e21 + this.t2z3 * this.i2e22; const M = this.m1 + this.m2; if (this.k00 = (this.ax1 * this.ax1 + this.ay1 * this.ay1 + this.az1 * this.az1) * M, this.k01 = (this.ax1 * this.ax2 + this.ay1 * this.ay2 + this.az1 * this.az2) * M, this.k02 = (this.ax1 * this.ax3 + this.ay1 * this.ay3 + this.az1 * this.az3) * M, this.k10 = (this.ax2 * this.ax1 + this.ay2 * this.ay1 + this.az2 * this.az1) * M, this.k11 = (this.ax2 * this.ax2 + this.ay2 * this.ay2 + this.az2 * this.az2) * M, this.k12 = (this.ax2 * this.ax3 + this.ay2 * this.ay3 + this.az2 * this.az3) * M, this.k20 = (this.ax3 * this.ax1 + this.ay3 * this.ay1 + this.az3 * this.az1) * M, this.k21 = (this.ax3 * this.ax2 + this.ay3 * this.ay2 + this.az3 * this.az2) * M, this.k22 = (this.ax3 * this.ax3 + this.ay3 * this.ay3 + this.az3 * this.az3) * M, this.k00 += this.t1x1 * this.a1x1 + this.t1y1 * this.a1y1 + this.t1z1 * this.a1z1, this.k01 += this.t1x1 * this.a1x2 + this.t1y1 * this.a1y2 + this.t1z1 * this.a1z2, this.k02 += this.t1x1 * this.a1x3 + this.t1y1 * this.a1y3 + this.t1z1 * this.a1z3, this.k10 += this.t1x2 * this.a1x1 + this.t1y2 * this.a1y1 + this.t1z2 * this.a1z1, this.k11 += this.t1x2 * this.a1x2 + this.t1y2 * this.a1y2 + this.t1z2 * this.a1z2, this.k12 += this.t1x2 * this.a1x3 + this.t1y2 * this.a1y3 + this.t1z2 * this.a1z3, this.k20 += this.t1x3 * this.a1x1 + this.t1y3 * this.a1y1 + this.t1z3 * this.a1z1, this.k21 += this.t1x3 * this.a1x2 + this.t1y3 * this.a1y2 + this.t1z3 * this.a1z2, this.k22 += this.t1x3 * this.a1x3 + this.t1y3 * this.a1y3 + this.t1z3 * this.a1z3, this.k00 += this.t2x1 * this.a2x1 + this.t2y1 * this.a2y1 + this.t2z1 * this.a2z1, this.k01 += this.t2x1 * this.a2x2 + this.t2y1 * this.a2y2 + this.t2z1 * this.a2z2, this.k02 += this.t2x1 * this.a2x3 + this.t2y1 * this.a2y3 + this.t2z1 * this.a2z3, this.k10 += this.t2x2 * this.a2x1 + this.t2y2 * this.a2y1 + this.t2z2 * this.a2z1, this.k11 += this.t2x2 * this.a2x2 + this.t2y2 * this.a2y2 + this.t2z2 * this.a2z2, this.k12 += this.t2x2 * this.a2x3 + this.t2y2 * this.a2y3 + this.t2z2 * this.a2z3, this.k20 += this.t2x3 * this.a2x1 + this.t2y3 * this.a2y1 + this.t2z3 * this.a2z1, this.k21 += this.t2x3 * this.a2x2 + this.t2y3 * this.a2y2 + this.t2z3 * this.a2z2, this.k22 += this.t2x3 * this.a2x3 + this.t2y3 * this.a2y3 + this.t2z3 * this.a2z3, this.kv00 = this.k00, this.kv11 = this.k11, this.kv22 = this.k22, this.dv00 = 1 / this.kv00, this.dv11 = 1 / this.kv11, this.dv22 = 1 / this.kv22, u && this.limitState1 != 2) { var g = 6.2831853 * c; var I = g * g * t; var V = i / (I + 2 * this.limitMotor1.dampingRatio * g); this.cfm1 = this.kv00 * V, this.limitVelocity1 *= I * V; } else this.cfm1 = 0, this.limitVelocity1 *= 0.05 * i; y && this.limitState2 != 2 ? (V = i / ((I = (g = 6.2831853 * m) * g * t) + 2 * this.limitMotor2.dampingRatio * g), this.cfm2 = this.kv11 * V, this.limitVelocity2 *= I * V) : (this.cfm2 = 0, this.limitVelocity2 *= 0.05 * i), x && this.limitState3 != 2 ? (V = i / ((I = (g = 6.2831853 * p) * g * t) + 2 * this.limitMotor3.dampingRatio * g), this.cfm3 = this.kv22 * V, this.limitVelocity3 *= I * V) : (this.cfm3 = 0, this.limitVelocity3 *= 0.05 * i), this.k00 += this.cfm1, this.k11 += this.cfm2, this.k22 += this.cfm3; const L = 1 / (this.k00 * (this.k11 * this.k22 - this.k21 * this.k12) + this.k10 * (this.k21 * this.k02 - this.k01 * this.k22) + this.k20 * (this.k01 * this.k12 - this.k11 * this.k02)); this.d00 = (this.k11 * this.k22 - this.k12 * this.k21) * L, this.d01 = (this.k02 * this.k21 - this.k01 * this.k22) * L, this.d02 = (this.k01 * this.k12 - this.k02 * this.k11) * L, this.d10 = (this.k12 * this.k20 - this.k10 * this.k22) * L, this.d11 = (this.k00 * this.k22 - this.k02 * this.k20) * L, this.d12 = (this.k02 * this.k10 - this.k00 * this.k12) * L, this.d20 = (this.k10 * this.k21 - this.k11 * this.k20) * L, this.d21 = (this.k01 * this.k20 - this.k00 * this.k21) * L, this.d22 = (this.k00 * this.k11 - this.k01 * this.k10) * L; const S = this.limitImpulse1 + this.motorImpulse1; const P = this.limitImpulse2 + this.motorImpulse2; const T = this.limitImpulse3 + this.motorImpulse3; this.l1.x += S * this.l1x1 + P * this.l1x2 + T * this.l1x3, this.l1.y += S * this.l1y1 + P * this.l1y2 + T * this.l1y3, this.l1.z += S * this.l1z1 + P * this.l1z2 + T * this.l1z3, this.a1.x += S * this.a1x1 + P * this.a1x2 + T * this.a1x3, this.a1.y += S * this.a1y1 + P * this.a1y2 + T * this.a1y3, this.a1.z += S * this.a1z1 + P * this.a1z2 + T * this.a1z3, this.l2.x -= S * this.l2x1 + P * this.l2x2 + T * this.l2x3, this.l2.y -= S * this.l2y1 + P * this.l2y2 + T * this.l2y3, this.l2.z -= S * this.l2z1 + P * this.l2z2 + T * this.l2z3, this.a2.x -= S * this.a2x1 + P * this.a2x2 + T * this.a2x3, this.a2.y -= S * this.a2y1 + P * this.a2y2 + T * this.a2y3, this.a2.z -= S * this.a2z1 + P * this.a2z2 + T * this.a2z3; }, solve() { const t = this.l2.x - this.l1.x + this.a2.y * this.r2z - this.a2.z * this.r2y - this.a1.y * this.r1z + this.a1.z * this.r1y; const i = this.l2.y - this.l1.y + this.a2.z * this.r2x - this.a2.x * this.r2z - this.a1.z * this.r1x + this.a1.x * this.r1z; const s = this.l2.z - this.l1.z + this.a2.x * this.r2y - this.a2.y * this.r2x - this.a1.x * this.r1y + this.a1.y * this.r1x; let h = t * this.ax1 + i * this.ay1 + s * this.az1; let e = t * this.ax2 + i * this.ay2 + s * this.az2; let a = t * this.ax3 + i * this.ay3 + s * this.az3; const o = this.motorImpulse1; const n = this.motorImpulse2; const r = this.motorImpulse3; let l = 0; let c = 0; let m = 0; this.enableMotor1 && (l = (h - this.motorSpeed1) * this.dv00, this.motorImpulse1 += l, this.motorImpulse1 > this.maxMotorImpulse1 ? this.motorImpulse1 = this.maxMotorImpulse1 : this.motorImpulse1 < -this.maxMotorImpulse1 && (this.motorImpulse1 = -this.maxMotorImpulse1), l = this.motorImpulse1 - o), this.enableMotor2 && (c = (e - this.motorSpeed2) * this.dv11, this.motorImpulse2 += c, this.motorImpulse2 > this.maxMotorImpulse2 ? this.motorImpulse2 = this.maxMotorImpulse2 : this.motorImpulse2 < -this.maxMotorImpulse2 && (this.motorImpulse2 = -this.maxMotorImpulse2), c = this.motorImpulse2 - n), this.enableMotor3 && (m = (a - this.motorSpeed3) * this.dv22, this.motorImpulse3 += m, this.motorImpulse3 > this.maxMotorImpulse3 ? this.motorImpulse3 = this.maxMotorImpulse3 : this.motorImpulse3 < -this.maxMotorImpulse3 && (this.motorImpulse3 = -this.maxMotorImpulse3), m = this.motorImpulse3 - r), h += l * this.kv00 + c * this.k01 + m * this.k02, e += l * this.k10 + c * this.kv11 + m * this.k12, a += l * this.k20 + c * this.k21 + m * this.kv22, h -= this.limitVelocity1 + this.limitImpulse1 * this.cfm1, e -= this.limitVelocity2 + this.limitImpulse2 * this.cfm2, a -= this.limitVelocity3 + this.limitImpulse3 * this.cfm3; const p = this.limitImpulse1; const u = this.limitImpulse2; const y = this.limitImpulse3; let x = h * this.d00 + e * this.d01 + a * this.d02; let d = h * this.d10 + e * this.d11 + a * this.d12; let f = h * this.d20 + e * this.d21 + a * this.d22; this.limitImpulse1 += x, this.limitImpulse2 += d, this.limitImpulse3 += f; let b; let v = 0; switch ((this.limitState1 == 2 || this.limitImpulse1 * this.limitState1 < 0) && (e += (x = -p) * this.k10, a += x * this.k20, v |= 1), (this.limitState2 == 2 || this.limitImpulse2 * this.limitState2 < 0) && (h += (d = -u) * this.k01, a += d * this.k21, v |= 2), (this.limitState3 == 2 || this.limitImpulse3 * this.limitState3 < 0) && (h += (f = -y) * this.k02, e += f * this.k12, v |= 4), v) { case 1: b = 1 / (this.k11 * this.k22 - this.k12 * this.k21), d = (this.k22 * e + -this.k12 * a) * b, f = (-this.k21 * e + this.k11 * a) * b; break; case 2: b = 1 / (this.k00 * this.k22 - this.k02 * this.k20), x = (this.k22 * h + -this.k02 * a) * b, f = (-this.k20 * h + this.k00 * a) * b; break; case 3: f = a / this.k22; break; case 4: b = 1 / (this.k00 * this.k11 - this.k01 * this.k10), x = (this.k11 * h + -this.k01 * e) * b, d = (-this.k10 * h + this.k00 * e) * b; break; case 5: d = e / this.k11; break; case 6: x = h / this.k00; } this.limitImpulse1 = p + x, this.limitImpulse2 = u + d, this.limitImpulse3 = y + f; const z = l + x; const N = c + d; const k = m + f; this.l1.x += z * this.l1x1 + N * this.l1x2 + k * this.l1x3, this.l1.y += z * this.l1y1 + N * this.l1y2 + k * this.l1y3, this.l1.z += z * this.l1z1 + N * this.l1z2 + k * this.l1z3, this.a1.x += z * this.a1x1 + N * this.a1x2 + k * this.a1x3, this.a1.y += z * this.a1y1 + N * this.a1y2 + k * this.a1y3, this.a1.z += z * this.a1z1 + N * this.a1z2 + k * this.a1z3, this.l2.x -= z * this.l2x1 + N * this.l2x2 + k * this.l2x3, this.l2.y -= z * this.l2y1 + N * this.l2y2 + k * this.l2y3, this.l2.z -= z * this.l2z1 + N * this.l2z2 + k * this.l2z3, this.a2.x -= z * this.a2x1 + N * this.a2x2 + k * this.a2x3, this.a2.y -= z * this.a2y1 + N * this.a2y2 + k * this.a2y3, this.a2.z -= z * this.a2z1 + N * this.a2z2 + k * this.a2z3; } }), G.prototype = Object.assign(Object.create(_.prototype), {
    constructor: G, preSolve(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize(), this.tan.tangent(this.nor).normalize(), this.bin.crossVectors(this.nor, this.tan), this.ac.preSolve(t, i), this.t3.preSolve(t, i); }, solve() { this.ac.solve(), this.t3.solve(); }, postSolve() {},
  }), $.prototype = Object.assign(Object.create(_.prototype), {
    constructor: $, preSolve(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, !0), this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize(), this.tan.tangent(this.nor).normalize(), this.bin.crossVectors(this.nor, this.tan), this.tmp.crossVectors(this.an1, this.an2); const s = g.acosClamp(g.dotVectors(this.an1, this.an2)); g.dotVectors(this.nor, this.tmp) < 0 ? this.rotationalLimitMotor.angle = -s : this.rotationalLimitMotor.angle = s, this.tmp.crossVectors(this.ax1, this.ax2), this.r3.limitMotor2.angle = g.dotVectors(this.tan, this.tmp), this.r3.limitMotor3.angle = g.dotVectors(this.bin, this.tmp), this.r3.preSolve(t, i), this.t3.preSolve(t, i); }, solve() { this.r3.solve(), this.t3.solve(); }, postSolve() {},
  }), tt.prototype = Object.assign(Object.create(_.prototype), {
    constructor: tt, preSolve(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, !0), this.r3.limitMotor1.angle = g.dotVectors(this.ax1, this.ax2); let s = g.dotVectors(this.an1, this.ax2); g.dotVectors(this.ax1, this.tmp.crossVectors(this.an1, this.ax2)) < 0 ? this.rotationalLimitMotor1.angle = -s : this.rotationalLimitMotor1.angle = s, s = g.dotVectors(this.an2, this.ax1), g.dotVectors(this.ax2, this.tmp.crossVectors(this.an2, this.ax1)) < 0 ? this.rotationalLimitMotor2.angle = -s : this.rotationalLimitMotor2.angle = s, this.nor.crossVectors(this.ax1, this.ax2).normalize(), this.tan.crossVectors(this.nor, this.ax2).normalize(), this.bin.crossVectors(this.nor, this.ax1).normalize(), this.r3.preSolve(t, i), this.t3.preSolve(t, i); }, solve() { this.r3.solve(), this.t3.solve(); }, postSolve() {},
  }), ot.prototype = {
    constructor: ot, reset(t, i) { this.body1 = t.parent, this.body2 = i.parent, this.numPoints = 0; }, addPointVec(t, i, s, h) { const e = this.points[this.numPoints++]; e.position.copy(t), e.localPoint1.sub(t, this.body1.position).applyMatrix3(this.body1.rotation), e.localPoint2.sub(t, this.body2.position).applyMatrix3(this.body2.rotation), e.normal.copy(i), h && e.normal.negate(), e.normalImpulse = 0, e.penetration = s, e.warmStarted = !1; }, addPoint(t, i, s, h, e, a, o, n) { const r = this.points[this.numPoints++]; r.position.set(t, i, s), r.localPoint1.sub(r.position, this.body1.position).applyMatrix3(this.body1.rotation), r.localPoint2.sub(r.position, this.body2.position).applyMatrix3(this.body2.rotation), r.normalImpulse = 0, r.normal.set(h, e, a), n && r.normal.negate(), r.penetration = o, r.warmStarted = !1; },
  }, rt.prototype = Object.assign(Object.create(U.prototype), {
    constructor: rt, attach() { this.p1 = this.body1.position, this.p2 = this.body2.position, this.lv1 = this.body1.linearVelocity, this.av1 = this.body1.angularVelocity, this.lv2 = this.body2.linearVelocity, this.av2 = this.body2.angularVelocity, this.i1 = this.body1.inverseInertia, this.i2 = this.body2.inverseInertia; }, detach() { this.p1 = null, this.p2 = null, this.lv1 = null, this.lv2 = null, this.av1 = null, this.av2 = null, this.i1 = null, this.i2 = null; }, preSolve(t, i) { this.m1 = this.body1.inverseMass, this.m2 = this.body2.inverseMass; const s = this.m1 + this.m2; this.num = this.manifold.numPoints; for (var h, e, a, o, n, r, l, c = this.cs, m = 0; m < this.num; m++)h = this.ps[m], this.tmpP1.sub(h.position, this.p1), this.tmpP2.sub(h.position, this.p2), this.tmpC1.crossVectors(this.av1, this.tmpP1), this.tmpC2.crossVectors(this.av2, this.tmpP2), c.norImp = h.normalImpulse, c.tanImp = h.tangentImpulse, c.binImp = h.binormalImpulse, c.nor.copy(h.normal), this.tmp.set(this.lv2.x + this.tmpC2.x - (this.lv1.x + this.tmpC1.x), this.lv2.y + this.tmpC2.y - (this.lv1.y + this.tmpC1.y), this.lv2.z + this.tmpC2.z - (this.lv1.z + this.tmpC1.z)), e = g.dotVectors(c.nor, this.tmp), c.tan.set(this.tmp.x - e * c.nor.x, this.tmp.y - e * c.nor.y, this.tmp.z - e * c.nor.z), g.dotVectors(c.tan, c.tan) <= 0.04 && c.tan.tangent(c.nor), c.tan.normalize(), c.bin.crossVectors(c.nor, c.tan), c.norU1.scale(c.nor, this.m1), c.norU2.scale(c.nor, this.m2), c.tanU1.scale(c.tan, this.m1), c.tanU2.scale(c.tan, this.m2), c.binU1.scale(c.bin, this.m1), c.binU2.scale(c.bin, this.m2), c.norT1.crossVectors(this.tmpP1, c.nor), c.tanT1.crossVectors(this.tmpP1, c.tan), c.binT1.crossVectors(this.tmpP1, c.bin), c.norT2.crossVectors(this.tmpP2, c.nor), c.tanT2.crossVectors(this.tmpP2, c.tan), c.binT2.crossVectors(this.tmpP2, c.bin), r = this.i1, l = this.i2, c.norTU1.copy(c.norT1).applyMatrix3(r, !0), c.tanTU1.copy(c.tanT1).applyMatrix3(r, !0), c.binTU1.copy(c.binT1).applyMatrix3(r, !0), c.norTU2.copy(c.norT2).applyMatrix3(l, !0), c.tanTU2.copy(c.tanT2).applyMatrix3(l, !0), c.binTU2.copy(c.binT2).applyMatrix3(l, !0), this.tmpC1.crossVectors(c.norTU1, this.tmpP1), this.tmpC2.crossVectors(c.norTU2, this.tmpP2), this.tmp.add(this.tmpC1, this.tmpC2), c.norDen = 1 / (s + g.dotVectors(c.nor, this.tmp)), this.tmpC1.crossVectors(c.tanTU1, this.tmpP1), this.tmpC2.crossVectors(c.tanTU2, this.tmpP2), this.tmp.add(this.tmpC1, this.tmpC2), c.tanDen = 1 / (s + g.dotVectors(c.tan, this.tmp)), this.tmpC1.crossVectors(c.binTU1, this.tmpP1), this.tmpC2.crossVectors(c.binTU2, this.tmpP2), this.tmp.add(this.tmpC1, this.tmpC2), c.binDen = 1 / (s + g.dotVectors(c.bin, this.tmp)), h.warmStarted ? (a = h.normalImpulse, this.lv1.addScaledVector(c.norU1, a), this.av1.addScaledVector(c.norTU1, a), this.lv2.subScaledVector(c.norU2, a), this.av2.subScaledVector(c.norTU2, a), c.norImp = a, c.tanImp = 0, c.binImp = 0, e = 0) : (c.norImp = 0, c.tanImp = 0, c.binImp = 0), e > -1 && (e = 0), (o = this.restitution * -e) < (n = -(h.penetration + 0.005) * i * 0.05) && (o = n), c.norTar = o, c.last = m == this.num - 1, c = c.next; }, solve() { let t; let i; let s; let h; let e; let a; let o; let n; let r; this.tmplv1.copy(this.lv1), this.tmplv2.copy(this.lv2), this.tmpav1.copy(this.av1), this.tmpav2.copy(this.av2); for (let l = this.cs; e = l.norImp, a = l.tanImp, o = l.binImp, n = -e * this.friction, this.tmp.sub(this.tmplv2, this.tmplv1), t = a, s = o, (r = (a += i = (g.dotVectors(this.tmp, l.tan) + g.dotVectors(this.tmpav2, l.tanT2) - g.dotVectors(this.tmpav1, l.tanT1)) * l.tanDen) * a + (o += h = (g.dotVectors(this.tmp, l.bin) + g.dotVectors(this.tmpav2, l.binT2) - g.dotVectors(this.tmpav1, l.binT1)) * l.binDen) * o) > n * n && (a *= r = n / g.sqrt(r), o *= r), i = a - t, h = o - s, this.tmp.set(l.tanU1.x * i + l.binU1.x * h, l.tanU1.y * i + l.binU1.y * h, l.tanU1.z * i + l.binU1.z * h), this.tmplv1.addEqual(this.tmp), this.tmp.set(l.tanTU1.x * i + l.binTU1.x * h, l.tanTU1.y * i + l.binTU1.y * h, l.tanTU1.z * i + l.binTU1.z * h), this.tmpav1.addEqual(this.tmp), this.tmp.set(l.tanU2.x * i + l.binU2.x * h, l.tanU2.y * i + l.binU2.y * h, l.tanU2.z * i + l.binU2.z * h), this.tmplv2.subEqual(this.tmp), this.tmp.set(l.tanTU2.x * i + l.binTU2.x * h, l.tanTU2.y * i + l.binTU2.y * h, l.tanTU2.z * i + l.binTU2.z * h), this.tmpav2.subEqual(this.tmp), this.tmp.sub(this.tmplv2, this.tmplv1), t = e, (e += i = (g.dotVectors(this.tmp, l.nor) + g.dotVectors(this.tmpav2, l.norT2) - g.dotVectors(this.tmpav1, l.norT1) - l.norTar) * l.norDen) > 0 && (e = 0), i = e - t, this.tmplv1.addScaledVector(l.norU1, i), this.tmpav1.addScaledVector(l.norTU1, i), this.tmplv2.subScaledVector(l.norU2, i), this.tmpav2.subScaledVector(l.norTU2, i), l.norImp = e, l.tanImp = a, l.binImp = o, !l.last;)l = l.next; this.lv1.copy(this.tmplv1), this.lv2.copy(this.tmplv2), this.av1.copy(this.tmpav1), this.av2.copy(this.tmpav2); }, postSolve() { for (var t, i = this.cs, s = this.num; s--;)(t = this.ps[s]).normal.copy(i.nor), t.tangent.copy(i.tan), t.binormal.copy(i.bin), t.normalImpulse = i.norImp, t.tangentImpulse = i.tanImp, t.binormalImpulse = i.binImp, t.normalDenominator = i.norDen, t.tangentDenominator = i.tanDen, t.binormalDenominator = i.binDen, i = i.next; },
  }), Object.assign(lt.prototype, {
    Contact: !0, mixRestitution(t, i) { return g.sqrt(t * i); }, mixFriction(t, i) { return g.sqrt(t * i); }, updateManifold() { this.constraint.restitution = this.mixRestitution(this.shape1.restitution, this.shape2.restitution), this.constraint.friction = this.mixFriction(this.shape1.friction, this.shape2.friction); for (var t = this.manifold.numPoints, i = t; i--;) { var s = this.buffer[i]; var h = this.points[i]; s.lp1X = h.localPoint1.x, s.lp1Y = h.localPoint1.y, s.lp1Z = h.localPoint1.z, s.lp2X = h.localPoint2.x, s.lp2Y = h.localPoint2.y, s.lp2Z = h.localPoint2.z, s.impulse = h.normalImpulse; } this.manifold.numPoints = 0, this.detector.detectCollision(this.shape1, this.shape2, this.manifold); const e = this.manifold.numPoints; if (e == 0) return this.touching = !1, this.close = !1, void (this.dist = g.INF); for ((this.touching || this.dist < 0.001) && (this.close = !0), this.touching = !0, i = e; i--;) { for (var a = (h = this.points[i]).localPoint1.x, o = h.localPoint1.y, n = h.localPoint1.z, r = h.localPoint2.x, l = h.localPoint2.y, c = h.localPoint2.z, m = -1, p = 4e-4, u = t; u--;) { let y = (s = this.buffer[u]).lp1X - a; let x = s.lp1Y - o; let d = s.lp1Z - n; const f = y * y + x * x + d * d; const b = (y = s.lp2X - r) * y + (x = s.lp2Y - l) * x + (d = s.lp2Z - c) * d; f < b ? f < p && (p = f, m = u) : b < p && (p = b, m = u), p < this.dist && (this.dist = p); } if (m != -1) { const v = this.buffer[m]; this.buffer[m] = this.buffer[--t], this.buffer[t] = v, h.normalImpulse = v.impulse, h.warmStarted = !0; } else h.normalImpulse = 0, h.warmStarted = !1; } }, attach(t, i) { this.shape1 = t, this.shape2 = i, this.body1 = t.parent, this.body2 = i.parent, this.manifold.body1 = this.body1, this.manifold.body2 = this.body2, this.constraint.body1 = this.body1, this.constraint.body2 = this.body2, this.constraint.attach(), this.s1Link.shape = i, this.s1Link.body = this.body2, this.s2Link.shape = t, this.s2Link.body = this.body1, t.contactLink != null ? (this.s1Link.next = t.contactLink).prev = this.s1Link : this.s1Link.next = null, t.contactLink = this.s1Link, t.numContacts++, i.contactLink != null ? (this.s2Link.next = i.contactLink).prev = this.s2Link : this.s2Link.next = null, i.contactLink = this.s2Link, i.numContacts++, this.b1Link.shape = i, this.b1Link.body = this.body2, this.b2Link.shape = t, this.b2Link.body = this.body1, this.body1.contactLink != null ? (this.b1Link.next = this.body1.contactLink).prev = this.b1Link : this.b1Link.next = null, this.body1.contactLink = this.b1Link, this.body1.numContacts++, this.body2.contactLink != null ? (this.b2Link.next = this.body2.contactLink).prev = this.b2Link : this.b2Link.next = null, this.body2.contactLink = this.b2Link, this.body2.numContacts++, this.prev = null, this.next = null, this.persisting = !0, this.sleeping = this.body1.sleeping && this.body2.sleeping, this.manifold.numPoints = 0; }, detach() { let t = this.s1Link.prev; let i = this.s1Link.next; t !== null && (t.next = i), i !== null && (i.prev = t), this.shape1.contactLink == this.s1Link && (this.shape1.contactLink = i), this.s1Link.prev = null, this.s1Link.next = null, this.s1Link.shape = null, this.s1Link.body = null, this.shape1.numContacts--, t = this.s2Link.prev, i = this.s2Link.next, t !== null && (t.next = i), i !== null && (i.prev = t), this.shape2.contactLink == this.s2Link && (this.shape2.contactLink = i), this.s2Link.prev = null, this.s2Link.next = null, this.s2Link.shape = null, this.s2Link.body = null, this.shape2.numContacts--, t = this.b1Link.prev, i = this.b1Link.next, t !== null && (t.next = i), i !== null && (i.prev = t), this.body1.contactLink == this.b1Link && (this.body1.contactLink = i), this.b1Link.prev = null, this.b1Link.next = null, this.b1Link.shape = null, this.b1Link.body = null, this.body1.numContacts--, t = this.b2Link.prev, i = this.b2Link.next, t !== null && (t.next = i), i !== null && (i.prev = t), this.body2.contactLink == this.b2Link && (this.body2.contactLink = i), this.b2Link.prev = null, this.b2Link.next = null, this.b2Link.shape = null, this.b2Link.body = null, this.body2.numContacts--, this.manifold.body1 = null, this.manifold.body2 = null, this.constraint.body1 = null, this.constraint.body2 = null, this.constraint.detach(), this.shape1 = null, this.shape2 = null, this.body1 = null, this.body2 = null; },
  }), Object.assign(ct.prototype, {
    setParent(t) { this.parent = t, this.scale = this.parent.scale, this.invScale = this.parent.invScale, this.id = this.parent.numRigidBodies, this.name || (this.name = this.id), this.updateMesh(); },
    addShape(t) { t.parent && I('RigidBody', 'It is not possible that you add a shape which already has an associated body.'), this.shapes != null && ((this.shapes.prev = t).next = this.shapes), this.shapes = t, t.parent = this, this.parent && this.parent.addShape(t), this.numShapes++; },
    removeShape(t) { const i = t; if (i.parent == this) { const s = i.prev; const h = i.next; s != null && (s.next = h), h != null && (h.prev = s), this.shapes == i && (this.shapes = h), i.prev = null, i.next = null, i.parent = null, this.parent && this.parent.removeShape(i), this.numShapes--; } },
    remove() { this.dispose(); },
    dispose() { this.parent.removeRigidBody(this); },
    checkContact(t) { this.parent.checkContact(this.name, t); },
    setupMass(t, i) { const s = void 0 === i || i; this.type = t || 2, this.isDynamic = this.type === 1, this.isStatic = this.type === 2, this.mass = 0, this.localInertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0); for (var h = new P(), e = new L(), a = this.shapes; a !== null; a = a.next) { a.calculateMassInfo(this.massInfo); const o = this.massInfo.mass; e.addScaledVector(a.relativePosition, o), this.mass += o, this.rotateInertia(a.relativeRotation, this.massInfo.inertia, h), this.localInertia.add(h), this.localInertia.addOffset(o, a.relativePosition); } if (this.inverseMass = 1 / this.mass, e.scaleEqual(this.inverseMass), s) { for (this.position.add(e), a = this.shapes; a !== null; a = a.next)a.relativePosition.subEqual(e); this.localInertia.subOffset(this.mass, e); } this.inverseLocalInertia.invert(this.localInertia), this.type === 2 && (this.inverseMass = 0, this.inverseLocalInertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0)), this.syncShapes(), this.awake(); },
    awake() { if (this.allowSleep && this.sleeping) { this.sleeping = !1, this.sleepTime = 0; for (let t = this.contactLink; t != null;)t.body.sleepTime = 0, t.body.sleeping = !1, t = t.next; for (let i = this.jointLink; i != null;)i.body.sleepTime = 0, i.body.sleeping = !1, i = i.next; for (let s = this.shapes; s != null; s = s.next)s.updateProxy(); } },
    sleep() { if (this.allowSleep && !this.sleeping) { this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.sleepPosition.copy(this.position), this.sleepOrientation.copy(this.orientation), this.sleepTime = 0, this.sleeping = !0; for (let t = this.shapes; t != null; t = t.next)t.updateProxy(); } },
    testWakeUp() { (this.linearVelocity.testZero() || this.angularVelocity.testZero() || this.position.testDiff(this.sleepPosition) || this.orientation.testDiff(this.sleepOrientation)) && this.awake(); },
    isLonely() { return this.numJoints == 0 && this.numContacts == 0; },
    updatePosition(t) { switch (this.type) { case 2: this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.controlPos && (this.position.copy(this.newPosition), this.controlPos = !1), this.controlRot && (this.orientation.copy(this.newOrientation), this.controlRot = !1); break; case 1: this.isKinematic && (this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0)), this.controlPos && (this.linearVelocity.subVectors(this.newPosition, this.position).multiplyScalar(1 / t), this.controlPos = !1), this.controlRot && (this.angularVelocity.copy(this.getAxis()), this.orientation.copy(this.newOrientation), this.controlRot = !1), this.position.addScaledVector(this.linearVelocity, t), this.orientation.addTime(this.angularVelocity, t), this.updateMesh(); break; default: I('RigidBody', 'Invalid type.'); } this.syncShapes(), this.updateMesh(); },
    getAxis() { return new L(0, 1, 0).applyMatrix3(this.inverseLocalInertia, !0).normalize(); },
    rotateInertia(t, i, s) { this.tmpInertia.multiplyMatrices(t, i), s.multiplyMatrices(this.tmpInertia, t, !0); },
    syncShapes() { this.rotation.setQuat(this.orientation), this.rotateInertia(this.rotation, this.inverseLocalInertia, this.inverseInertia); for (let t = this.shapes; t != null; t = t.next)t.position.copy(t.relativePosition).applyMatrix3(this.rotation, !0).add(this.position), t.rotation.multiplyMatrices(this.rotation, t.relativeRotation), t.updateProxy(); },
    applyImpulse(t, i) {
      this.linearVelocity.addScaledVector(i, this.inverseMass); const s = (new L()).copy(t).sub(this.position).cross(i)
        .applyMatrix3(this.inverseInertia, !0); this.angularVelocity.add(s);
    },
    setPosition(t) { this.newPosition.copy(t).multiplyScalar(this.invScale), this.controlPos = !0, this.isKinematic || (this.isKinematic = !0); },
    setQuaternion(t) { this.newOrientation.set(t.x, t.y, t.z, t.w), this.controlRot = !0, this.isKinematic || (this.isKinematic = !0); },
    setRotation(t) { this.newOrientation = (new S()).setFromEuler(t.x * g.degtorad, t.y * g.degtorad, t.z * g.degtorad), this.controlRot = !0; },
    resetPosition(t, i, s) { this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.position.set(t, i, s).multiplyScalar(this.invScale), this.awake(); },
    resetQuaternion(t) { this.angularVelocity.set(0, 0, 0), this.orientation = new S(t.x, t.y, t.z, t.w), this.awake(); },
    resetRotation(t, i, s) { this.angularVelocity.set(0, 0, 0), this.orientation = (new S()).setFromEuler(t * g.degtorad, i * g.degtorad, s * g.degtorad), this.awake(); },
    getPosition() { return this.pos; },
    getQuaternion() { return this.quaternion; },
    connectMesh(t) { this.mesh = t, this.updateMesh(); },
    updateMesh() { this.pos.scale(this.position, this.scale), this.quaternion.copy(this.orientation), this.mesh !== null && (this.mesh.position.copy(this.getPosition()), this.mesh.quaternion.copy(this.getQuaternion())); },
  }), Object.assign(pt.prototype, {
    BroadPhase: !0, createProxy(t) { I('BroadPhase', 'Inheritance error.'); }, addProxy(t) { I('BroadPhase', 'Inheritance error.'); }, removeProxy(t) { I('BroadPhase', 'Inheritance error.'); }, isAvailablePair(t, i) { let s; const h = t.parent; const e = i.parent; if (h == e || !h.isDynamic && !e.isDynamic || (t.belongsTo & i.collidesWith) == 0 || (i.belongsTo & t.collidesWith) == 0) return !1; for (s = h.numJoints < e.numJoints ? h.jointLink : e.jointLink; s !== null;) { const a = s.joint; if (!a.allowCollision && (a.body1 == h && a.body2 == e || a.body1 == e && a.body2 == h)) return !1; s = s.next; } return !0; }, detectPairs() { this.pairs = [], this.numPairs = 0, this.numPairChecks = 0, this.collectPairs(); }, collectPairs() {}, addPair(t, i) { const s = new mt(t, i); this.pairs.push(s), this.numPairs++; },
  }); let ut = 0; function yt(t) { this.shape = t, this.aabb = t.aabb; } function xt(t) { yt.call(this, t), this.id = ut++; } function dt() { pt.call(this), this.types = r, this.proxies = []; } function ft() { this.numElements = 0, this.bufferSize = 256, this.elements = [], this.elements.length = this.bufferSize, this.stack = new Float32Array(64); } function bt(t, i) { this.proxy = t, this.pair = null, this.min1 = null, this.max1 = null, this.min2 = null, this.max2 = null, this.max = i, this.value = 0; } function vt(t, i) { yt.call(this, i), this.belongsTo = 0, this.max = [], this.min = [], this.sap = t, this.min[0] = new bt(this, !1), this.max[0] = new bt(this, !0), this.min[1] = new bt(this, !1), this.max[1] = new bt(this, !0), this.min[2] = new bt(this, !1), this.max[2] = new bt(this, !0), this.max[0].pair = this.min[0], this.max[1].pair = this.min[1], this.max[2].pair = this.min[2], this.min[0].min1 = this.min[1], this.min[0].max1 = this.max[1], this.min[0].min2 = this.min[2], this.min[0].max2 = this.max[2], this.min[1].min1 = this.min[0], this.min[1].max1 = this.max[0], this.min[1].min2 = this.min[2], this.min[1].max2 = this.max[2], this.min[2].min1 = this.min[0], this.min[2].max1 = this.max[0], this.min[2].min2 = this.min[1], this.min[2].max2 = this.max[1]; } function zt() { pt.call(this), this.types = l, this.numElementsD = 0, this.numElementsS = 0, this.axesD = [new ft(), new ft(), new ft()], this.axesS = [new ft(), new ft(), new ft()], this.index1 = 0, this.index2 = 1; } function Nt() { this.child1 = null, this.child2 = null, this.parent = null, this.proxy = null, this.height = 0, this.aabb = new T(); } function kt() { this.root = null, this.freeNodes = [], this.freeNodes.length = 16384, this.numFreeNodes = 0, this.aabb = new T(); } function wt(t) { yt.call(this, t), this.leaf = new Nt(), this.leaf.proxy = this; } function Mt() { pt.call(this), this.types = c, this.tree = new kt(), this.stack = [], this.leaves = [], this.numLeaves = 0; } function gt() { this.flip = !1; } function It() { gt.call(this), this.clipVertices1 = new Float32Array(24), this.clipVertices2 = new Float32Array(24), this.used = new Float32Array(8), this.INF = 1 / 0; } function Vt(t) { gt.call(this), this.flip = t; } function Lt() { gt.call(this); } function St(t) { gt.call(this), this.flip = t; } function Pt(t) { gt.call(this), this.flip = t; } function Tt() { gt.call(this); } function At(t) { gt.call(this), this.flip = t, this.n = new L(), this.p = new L(); } function jt(t) { gt.call(this), this.flip = t, this.n = new L(), this.p = new L(), this.dix = new L(), this.diy = new L(), this.diz = new L(), this.cc = new L(), this.cc2 = new L(); } function Ct(t) { switch (t instanceof Object || (t = {}), this.scale = t.worldscale || 1, this.invScale = 1 / this.scale, this.timeStep = t.timestep || 0.01666, this.timerate = 1e3 * this.timeStep, this.timer = null, this.preLoop = null, this.postLoop = null, this.numIterations = t.iterations || 8, t.broadphase || 2) { case 1: this.broadPhase = new dt(); break; case 2: default: this.broadPhase = new zt(); break; case 3: this.broadPhase = new Mt(); } this.Btypes = ['None', 'BruteForce', 'Sweep & Prune', 'Bounding Volume Tree'], this.broadPhaseType = this.Btypes[t.broadphase || 2], this.performance = null, this.isStat = void 0 !== t.info && t.info, this.isStat && (this.performance = new V(this)), this.enableRandomizer = void 0 === t.random || t.random, this.rigidBodies = null, this.numRigidBodies = 0, this.contacts = null, this.unusedContacts = null, this.numContacts = 0, this.numContactPoints = 0, this.joints = null, this.numJoints = 0, this.numIslands = 0, this.gravity = new L(0, -9.8, 0), void 0 !== t.gravity && this.gravity.fromArray(t.gravity); this.detectors = [], this.detectors.length = 5; for (let i = 5; i--;) this.detectors[i] = [], this.detectors[i].length = 5; this.detectors[u][u] = new Tt(), this.detectors[u][y] = new St(!1), this.detectors[y][u] = new St(!0), this.detectors[y][y] = new It(), this.detectors[x][x] = new Lt(), this.detectors[x][y] = new Vt(!0), this.detectors[y][x] = new Vt(!1), this.detectors[x][u] = new Pt(!0), this.detectors[u][x] = new Pt(!1), this.detectors[d][u] = new At(!0), this.detectors[u][d] = new At(!1), this.detectors[d][y] = new jt(!0), this.detectors[y][d] = new jt(!1), this.randX = 65535, this.randA = 98765, this.randB = 123456789, this.islandRigidBodies = [], this.islandStack = [], this.islandConstraints = []; }Object.assign(yt.prototype, { Proxy: !0, update() { I('Proxy', 'Inheritance error.'); } }), xt.prototype = Object.assign(Object.create(yt.prototype), { constructor: xt, update() {} }), dt.prototype = Object.assign(Object.create(pt.prototype), {
    constructor: dt, createProxy(t) { return new xt(t); }, addProxy(t) { this.proxies.push(t); }, removeProxy(t) { const i = this.proxies.indexOf(t); i > -1 && this.proxies.splice(i, 1); }, collectPairs() { let t; let i; let s; let h = 0; const e = this.proxies; const a = e.length; for (this.numPairChecks = a * (a - 1) >> 1; h < a;) for (i = e[h++], t = h + 1; t < a;)s = e[t++], !i.aabb.intersectTest(s.aabb) && this.isAvailablePair(i.shape, s.shape) && this.addPair(i.shape, s.shape); },
  }), Object.assign(ft.prototype, {
    SAPAxis: !0, addElements(t, i) { if (this.numElements + 2 >= this.bufferSize) { this.bufferSize *= 2; for (let s = [], h = this.numElements; h--;)s[h] = this.elements[h]; } this.elements[this.numElements++] = t, this.elements[this.numElements++] = i; }, removeElements(t, i) { for (var s = -1, h = -1, e = 0, a = this.numElements; e < a; e++) { const o = this.elements[e]; if (o == t || o == i) { if (s != -1) { h = e; break; }s = e; } } for (e = s + 1, a = h; e < a; e++) this.elements[e - 1] = this.elements[e]; for (e = h + 1, a = this.numElements; e < a; e++) this.elements[e - 2] = this.elements[e]; this.elements[--this.numElements] = null, this.elements[--this.numElements] = null; }, sort() { for (var t = 0, i = 1; this.numElements >> i != 0;)i++; i = i * this.numElements >> 2, t = 0; for (var s = !1, h = this.elements, e = 1, a = this.numElements; e < a; e++) { var o = h[e]; var n = o.value; var r = h[e - 1]; if (r.value > n) { var l = e; do { if (h[l] = r, --l == 0) break; r = h[l - 1]; } while (r.value > n); if (h[l] = o, (t += e - l) > i) { s = !0; break; } } } if (s) { t = 2; const c = this.stack; for (c[0] = 0, c[1] = this.numElements - 1; t > 0;) { const m = c[--t]; const p = c[--t]; const u = m - p; if (u > 16) { const y = p + g.floor(0.5 * u); for (o = h[y], h[y] = h[m], h[m] = o, n = o.value, e = p - 1, l = m; ;) { var x; var d; do { x = h[++e]; } while (x.value < n); do { d = h[--l]; } while (n < d.value && l != p); if (e >= l) break; h[e] = d, h[l] = x; }h[m] = h[e], h[e] = o, e - p > m - e ? (c[t++] = p, c[t++] = e - 1, c[t++] = e + 1, c[t++] = m) : (c[t++] = e + 1, c[t++] = m, c[t++] = p, c[t++] = e - 1); } else for (e = p + 1; e <= m; e++) if (n = (o = h[e]).value, (r = h[e - 1]).value > n) { l = e; do { if (h[l] = r, --l == 0) break; r = h[l - 1]; } while (r.value > n); h[l] = o; } } } }, calculateTestCount() { for (var t = 1, i = 0, s = 1, h = this.numElements; s < h; s++) this.elements[s].max ? t-- : (i += t, t++); return i; },
  }), vt.prototype = Object.assign(Object.create(yt.prototype), { constructor: vt, isDynamic() { const t = this.shape.parent; return t.isDynamic && !t.sleeping; }, update() { const t = this.aabb.elements; this.min[0].value = t[0], this.min[1].value = t[1], this.min[2].value = t[2], this.max[0].value = t[3], this.max[1].value = t[4], this.max[2].value = t[5], (this.belongsTo == 1 && !this.isDynamic() || this.belongsTo == 2 && this.isDynamic()) && (this.sap.removeProxy(this), this.sap.addProxy(this)); } }), zt.prototype = Object.assign(Object.create(pt.prototype), {
    constructor: zt, createProxy(t) { return new vt(this, t); }, addProxy(t) { const i = t; i.isDynamic() ? (this.axesD[0].addElements(i.min[0], i.max[0]), this.axesD[1].addElements(i.min[1], i.max[1]), this.axesD[2].addElements(i.min[2], i.max[2]), i.belongsTo = 1, this.numElementsD += 2) : (this.axesS[0].addElements(i.min[0], i.max[0]), this.axesS[1].addElements(i.min[1], i.max[1]), this.axesS[2].addElements(i.min[2], i.max[2]), i.belongsTo = 2, this.numElementsS += 2); }, removeProxy(t) { const i = t; if (i.belongsTo != 0) { switch (i.belongsTo) { case 1: this.axesD[0].removeElements(i.min[0], i.max[0]), this.axesD[1].removeElements(i.min[1], i.max[1]), this.axesD[2].removeElements(i.min[2], i.max[2]), this.numElementsD -= 2; break; case 2: this.axesS[0].removeElements(i.min[0], i.max[0]), this.axesS[1].removeElements(i.min[1], i.max[1]), this.axesS[2].removeElements(i.min[2], i.max[2]), this.numElementsS -= 2; }i.belongsTo = 0; } }, collectPairs() { if (this.numElementsD != 0) { let t; let i; let s; let h; let e = this.axesD[this.index1]; let a = this.axesD[this.index2]; e.sort(), a.sort(), e.calculateTestCount() <= a.calculateTestCount() ? ((a = this.axesS[this.index1]).sort(), t = e.elements, i = a.elements) : ((e = this.axesS[this.index2]).sort(), t = a.elements, i = e.elements, this.index1 ^= this.index2, this.index2 ^= this.index1, this.index1 ^= this.index2); for (let o = 0, n = 0; o < this.numElementsD;) { var r; var l; if (n == this.numElementsS)r = t[o], l = !0, o++; else { const c = t[o]; const m = i[n]; c.value < m.value ? (r = c, l = !0, o++) : (r = m, l = !1, n++); } if (r.max) { const p = r.pair; if (l) { if (p == s) { s = s.pair; continue; }r = s; } else { if (p == h) { h = h.pair; continue; }r = h; } for (;r;) { if ((b = r.pair) == p) { r.pair = b.pair; break; }r = b; } } else { for (var u = r.proxy.shape, y = r.min1.value, x = r.max1.value, d = r.min2.value, f = r.max2.value, b = s; b != null; b = b.pair) { var v = b.proxy.shape; this.numPairChecks++, y > b.max1.value || x < b.min1.value || d > b.max2.value || f < b.min2.value || !this.isAvailablePair(u, v) || this.addPair(u, v); } if (l) { for (b = h; b != null; b = b.pair)v = b.proxy.shape, this.numPairChecks++, y > b.max1.value || x < b.min1.value || d > b.max2.value || f < b.min2.value || !this.isAvailablePair(u, v) || this.addPair(u, v); r.pair = s, s = r; } else r.pair = h, h = r; } } this.index2 = 3 ^ (this.index1 | this.index2); } },
  }), Object.assign(kt.prototype, {
    DBVT: !0, moveLeaf(t) { this.deleteLeaf(t), this.insertLeaf(t); }, insertLeaf(t) { if (this.root != null) { for (var i, s, h = t.aabb, e = this.root; e.proxy == null;) { const a = e.child1; const o = e.child2; const n = e.aabb; const r = a.aabb; const l = o.aabb; i = n.surfaceArea(), this.aabb.combine(h, n); const c = 2 * (s = this.aabb.surfaceArea()); const m = 2 * (s - i); let p = m; this.aabb.combine(h, r), a.proxy != null ? p += this.aabb.surfaceArea() : p += this.aabb.surfaceArea() - r.surfaceArea(); let u = m; if (this.aabb.combine(h, l), o.proxy != null ? u += this.aabb.surfaceArea() : u += this.aabb.surfaceArea() - l.surfaceArea(), p < u) { if (c < p) break; e = a; } else { if (c < u) break; e = o; } } let y; const x = e.parent; (y = this.numFreeNodes > 0 ? this.freeNodes[--this.numFreeNodes] : new Nt()).parent = x, y.child1 = t, y.child2 = e, y.aabb.combine(t.aabb, e.aabb), y.height = e.height + 1, e.parent = y, t.parent = y, e == this.root ? this.root = y : x.child1 == e ? x.child1 = y : x.child2 = y; do { y = this.balance(y), this.fix(y), y = y.parent; } while (y != null); } else this.root = t; }, getBalance(t) { return t.proxy != null ? 0 : t.child1.height - t.child2.height; }, deleteLeaf(t) { if (t != this.root) { let i; const s = t.parent; if (i = s.child1 == t ? s.child2 : s.child1, s == this.root) return this.root = i, void (i.parent = null); let h = s.parent; i.parent = h, h.child1 == s ? h.child1 = i : h.child2 = i, this.numFreeNodes < 16384 && (this.freeNodes[this.numFreeNodes++] = s); do { h = this.balance(h), this.fix(h), h = h.parent; } while (h != null); } else this.root = null; }, balance(t) { const i = t.height; if (i < 2) return t; let s; const h = t.parent; const e = t.child1; const a = t.child2; const o = e.height; const n = a.height; const r = o - n; if (r > 1) { const l = e.child1; const c = e.child2; const m = l.height; const p = c.height; return m > p ? (e.child2 = t, t.parent = e, t.child1 = c, c.parent = t, t.aabb.combine(c.aabb, a.aabb), s = p - n, t.height = p - (s & s >> 31) + 1, e.aabb.combine(l.aabb, t.aabb), s = m - i, e.height = m - (s & s >> 31) + 1) : (e.child1 = t, t.parent = e, t.child1 = l, l.parent = t, t.aabb.combine(l.aabb, a.aabb), s = m - n, t.height = m - (s & s >> 31) + 1, e.aabb.combine(t.aabb, c.aabb), s = i - p, e.height = i - (s & s >> 31) + 1), h != null ? h.child1 == t ? h.child1 = e : h.child2 = e : this.root = e, e.parent = h, e; } if (r < -1) { const u = a.child1; const y = a.child2; const x = u.height; const d = y.height; return x > d ? (a.child2 = t, t.parent = a, t.child2 = y, y.parent = t, t.aabb.combine(e.aabb, y.aabb), s = o - d, t.height = o - (s & s >> 31) + 1, a.aabb.combine(u.aabb, t.aabb), s = x - i, a.height = x - (s & s >> 31) + 1) : (a.child1 = t, t.parent = a, t.child2 = u, u.parent = t, t.aabb.combine(e.aabb, u.aabb), s = o - x, t.height = o - (s & s >> 31) + 1, a.aabb.combine(t.aabb, y.aabb), s = i - d, a.height = i - (s & s >> 31) + 1), h != null ? h.child1 == t ? h.child1 = a : h.child2 = a : this.root = a, a.parent = h, a; } return t; }, fix(t) { const i = t.child1; const s = t.child2; t.aabb.combine(i.aabb, s.aabb), t.height = i.height < s.height ? s.height + 1 : i.height + 1; },
  }), wt.prototype = Object.assign(Object.create(yt.prototype), { constructor: wt, update() {} }), Mt.prototype = Object.assign(Object.create(pt.prototype), {
    constructor: Mt, createProxy(t) { return new wt(t); }, addProxy(t) { this.tree.insertLeaf(t.leaf), this.leaves.push(t.leaf), this.numLeaves++; }, removeProxy(t) { this.tree.deleteLeaf(t.leaf); const i = this.leaves.indexOf(t.leaf); i > -1 && (this.leaves.splice(i, 1), this.numLeaves--); }, collectPairs() { if (!(this.numLeaves < 2)) for (var t, i = this.numLeaves; i--;)(t = this.leaves[i]).proxy.aabb.intersectTestTwo(t.aabb) && (t.aabb.copy(t.proxy.aabb, 0.1), this.tree.deleteLeaf(t), this.tree.insertLeaf(t), this.collide(t, this.tree.root)); }, collide(t, i) { let s; let h; let e; let a; let o; let n; let r = 2; for (this.stack[0] = t, this.stack[1] = i; r > 0;) if (e = this.stack[--r], a = this.stack[--r], o = e.proxy != null, n = a.proxy != null, this.numPairChecks++, o && n) { if ((s = e.proxy.shape) == (h = a.proxy.shape) || s.aabb.intersectTest(h.aabb) || !this.isAvailablePair(s, h)) continue; this.addPair(s, h); } else { if (e.aabb.intersectTest(a.aabb)) continue; n || !o && e.aabb.surfaceArea() > a.aabb.surfaceArea() ? (this.stack[r++] = e.child1, this.stack[r++] = a, this.stack[r++] = e.child2, this.stack[r++] = a) : (this.stack[r++] = e, this.stack[r++] = a.child1, this.stack[r++] = e, this.stack[r++] = a.child2); } },
  }), Object.assign(gt.prototype, { CollisionDetector: !0, detectCollision(t, i, s) { I('CollisionDetector', 'Inheritance error.'); } }), It.prototype = Object.assign(Object.create(gt.prototype), { constructor: It, detectCollision(t, i, s) { let h; let e; t.id < i.id ? (h = t, e = i) : (h = i, e = t); let a; let o; let n; let r; let l; let c; let m; let p; let u; let y; let x; let d; let f; let b; let v; let z; let N; let k; let w; let M; let I; let V; let L; let S; let P; let T; let A; let j; let C; let O; let D; let E; let B; let F; let q; const U = h.elements; const R = e.elements; const _ = h.dimentions; const J = e.dimentions; const W = h.position; const H = e.position; const Q = W.x; const X = W.y; const Y = W.z; const Z = H.x; const K = H.y; const G = H.z; const $ = Z - Q; const tt = K - X; const it = G - Y; const st = h.halfWidth; const ht = h.halfHeight; const et = h.halfDepth; const at = e.halfWidth; const ot = e.halfHeight; const nt = e.halfDepth; const rt = _[0]; const lt = _[1]; const ct = _[2]; const mt = _[3]; const pt = _[4]; const ut = _[5]; const yt = _[6]; const xt = _[7]; const dt = _[8]; const ft = _[9]; const bt = _[10]; const vt = _[11]; const zt = _[12]; const Nt = _[13]; const kt = _[14]; const wt = _[15]; const Mt = _[16]; const gt = _[17]; const It = J[0]; const Vt = J[1]; const Lt = J[2]; const St = J[3]; const Pt = J[4]; const Tt = J[5]; const At = J[6]; const jt = J[7]; const Ct = J[8]; const Ot = J[9]; const Dt = J[10]; const Et = J[11]; const Bt = J[12]; const Ft = J[13]; const qt = J[14]; const Ut = J[15]; const Rt = J[16]; const _t = J[17]; let Jt = lt * Lt - ct * Vt; let Wt = ct * It - rt * Lt; let Ht = rt * Vt - lt * It; let Qt = lt * Tt - ct * Pt; let Xt = ct * St - rt * Tt; let Yt = rt * Pt - lt * St; let Zt = lt * Ct - ct * jt; let Kt = ct * At - rt * Ct; let Gt = rt * jt - lt * At; let $t = pt * Lt - ut * Vt; let ti = ut * It - mt * Lt; let ii = mt * Vt - pt * It; let si = pt * Tt - ut * Pt; let hi = ut * St - mt * Tt; let ei = mt * Pt - pt * St; let ai = pt * Ct - ut * jt; let oi = ut * At - mt * Ct; let ni = mt * jt - pt * At; let ri = xt * Lt - dt * Vt; let li = dt * It - yt * Lt; let ci = yt * Vt - xt * It; let mi = xt * Tt - dt * Pt; let pi = dt * St - yt * Tt; let ui = yt * Pt - xt * St; let yi = xt * Ct - dt * jt; let xi = dt * At - yt * Ct; let di = yt * jt - xt * At; let fi = !1; let bi = !1; let vi = !1; let zi = !1; let Ni = !1; let ki = !1; let wi = !1; let Mi = !1; let gi = !1; if ((a = (D = rt * $ + lt * tt + ct * it) > 0) || (D = -D), (B = rt * It + lt * Vt + ct * Lt) < 0 && (B = -B), (F = rt * St + lt * Pt + ct * Tt) < 0 && (F = -F), (q = rt * At + lt * jt + ct * Ct) < 0 && (q = -q), !((z = D - (E = st) - (B * at + F * ot + q * nt)) > 0 || ((o = (D = mt * $ + pt * tt + ut * it) > 0) || (D = -D), (B = mt * It + pt * Vt + ut * Lt) < 0 && (B = -B), (F = mt * St + pt * Pt + ut * Tt) < 0 && (F = -F), (q = mt * At + pt * jt + ut * Ct) < 0 && (q = -q), (N = D - (E = ht) - (B * at + F * ot + q * nt)) > 0 || ((n = (D = yt * $ + xt * tt + dt * it) > 0) || (D = -D), (B = yt * It + xt * Vt + dt * Lt) < 0 && (B = -B), (F = yt * St + xt * Pt + dt * Tt) < 0 && (F = -F), (q = yt * At + xt * jt + dt * Ct) < 0 && (q = -q), (k = D - (E = et) - (B * at + F * ot + q * nt)) > 0 || ((r = (D = It * $ + Vt * tt + Lt * it) > 0) || (D = -D), (B = It * rt + Vt * lt + Lt * ct) < 0 && (B = -B), (F = It * mt + Vt * pt + Lt * ut) < 0 && (F = -F), (q = It * yt + Vt * xt + Lt * dt) < 0 && (q = -q), (w = 1 * (D - (E = B * st + F * ht + q * et) - at)) > 0 || ((l = (D = St * $ + Pt * tt + Tt * it) > 0) || (D = -D), (B = St * rt + Pt * lt + Tt * ct) < 0 && (B = -B), (F = St * mt + Pt * pt + Tt * ut) < 0 && (F = -F), (q = St * yt + Pt * xt + Tt * dt) < 0 && (q = -q), (M = 1 * (D - (E = B * st + F * ht + q * et) - ot)) > 0 || ((c = (D = At * $ + jt * tt + Ct * it) > 0) || (D = -D), (B = At * rt + jt * lt + Ct * ct) < 0 && (B = -B), (F = At * mt + jt * pt + Ct * ut) < 0 && (F = -F), (q = At * yt + jt * xt + Ct * dt) < 0 && (q = -q), (I = 1 * (D - (E = B * st + F * ht + q * et) - nt)) > 0))))))) { if ((D = Jt * Jt + Wt * Wt + Ht * Ht) > 1e-5) { if ((m = (D = (Jt *= D = 1 / g.sqrt(D)) * $ + (Wt *= D) * tt + (Ht *= D) * it) > 0) || (D = -D), (B = Jt * mt + Wt * pt + Ht * ut) < 0 && (B = -B), (F = Jt * yt + Wt * xt + Ht * dt) < 0 && (F = -F), E = B * ht + F * et, (B = Jt * St + Wt * Pt + Ht * Tt) < 0 && (B = -B), (F = Jt * At + Wt * jt + Ht * Ct) < 0 && (F = -F), (V = D - E - (B * ot + F * nt)) > 0) return; } else m = !1, V = 0, fi = !0; if ((D = Qt * Qt + Xt * Xt + Yt * Yt) > 1e-5) { if ((p = (D = (Qt *= D = 1 / g.sqrt(D)) * $ + (Xt *= D) * tt + (Yt *= D) * it) > 0) || (D = -D), (B = Qt * mt + Xt * pt + Yt * ut) < 0 && (B = -B), (F = Qt * yt + Xt * xt + Yt * dt) < 0 && (F = -F), E = B * ht + F * et, (B = Qt * It + Xt * Vt + Yt * Lt) < 0 && (B = -B), (F = Qt * At + Xt * jt + Yt * Ct) < 0 && (F = -F), (L = D - E - (B * at + F * nt)) > 0) return; } else p = !1, L = 0, bi = !0; if ((D = Zt * Zt + Kt * Kt + Gt * Gt) > 1e-5) { if ((u = (D = (Zt *= D = 1 / g.sqrt(D)) * $ + (Kt *= D) * tt + (Gt *= D) * it) > 0) || (D = -D), (B = Zt * mt + Kt * pt + Gt * ut) < 0 && (B = -B), (F = Zt * yt + Kt * xt + Gt * dt) < 0 && (F = -F), E = B * ht + F * et, (B = Zt * It + Kt * Vt + Gt * Lt) < 0 && (B = -B), (F = Zt * St + Kt * Pt + Gt * Tt) < 0 && (F = -F), (S = D - E - (B * at + F * ot)) > 0) return; } else u = !1, S = 0, vi = !0; if ((D = $t * $t + ti * ti + ii * ii) > 1e-5) { if ((y = (D = ($t *= D = 1 / g.sqrt(D)) * $ + (ti *= D) * tt + (ii *= D) * it) > 0) || (D = -D), (B = $t * rt + ti * lt + ii * ct) < 0 && (B = -B), (F = $t * yt + ti * xt + ii * dt) < 0 && (F = -F), E = B * st + F * et, (B = $t * St + ti * Pt + ii * Tt) < 0 && (B = -B), (F = $t * At + ti * jt + ii * Ct) < 0 && (F = -F), (P = D - E - (B * ot + F * nt)) > 0) return; } else y = !1, P = 0, zi = !0; if ((D = si * si + hi * hi + ei * ei) > 1e-5) { if ((x = (D = (si *= D = 1 / g.sqrt(D)) * $ + (hi *= D) * tt + (ei *= D) * it) > 0) || (D = -D), (B = si * rt + hi * lt + ei * ct) < 0 && (B = -B), (F = si * yt + hi * xt + ei * dt) < 0 && (F = -F), E = B * st + F * et, (B = si * It + hi * Vt + ei * Lt) < 0 && (B = -B), (F = si * At + hi * jt + ei * Ct) < 0 && (F = -F), (T = D - E - (B * at + F * nt)) > 0) return; } else x = !1, T = 0, Ni = !0; if ((D = ai * ai + oi * oi + ni * ni) > 1e-5) { if ((d = (D = (ai *= D = 1 / g.sqrt(D)) * $ + (oi *= D) * tt + (ni *= D) * it) > 0) || (D = -D), (B = ai * rt + oi * lt + ni * ct) < 0 && (B = -B), (F = ai * yt + oi * xt + ni * dt) < 0 && (F = -F), E = B * st + F * et, (B = ai * It + oi * Vt + ni * Lt) < 0 && (B = -B), (F = ai * St + oi * Pt + ni * Tt) < 0 && (F = -F), (A = D - E - (B * at + F * ot)) > 0) return; } else d = !1, A = 0, ki = !0; if ((D = ri * ri + li * li + ci * ci) > 1e-5) { if ((f = (D = (ri *= D = 1 / g.sqrt(D)) * $ + (li *= D) * tt + (ci *= D) * it) > 0) || (D = -D), (B = ri * rt + li * lt + ci * ct) < 0 && (B = -B), (F = ri * mt + li * pt + ci * ut) < 0 && (F = -F), E = B * st + F * ht, (B = ri * St + li * Pt + ci * Tt) < 0 && (B = -B), (F = ri * At + li * jt + ci * Ct) < 0 && (F = -F), (j = D - E - (B * ot + F * nt)) > 0) return; } else f = !1, j = 0, wi = !0; if ((D = mi * mi + pi * pi + ui * ui) > 1e-5) { if ((b = (D = (mi *= D = 1 / g.sqrt(D)) * $ + (pi *= D) * tt + (ui *= D) * it) > 0) || (D = -D), (B = mi * rt + pi * lt + ui * ct) < 0 && (B = -B), (F = mi * mt + pi * pt + ui * ut) < 0 && (F = -F), E = B * st + F * ht, (B = mi * It + pi * Vt + ui * Lt) < 0 && (B = -B), (F = mi * At + pi * jt + ui * Ct) < 0 && (F = -F), (C = D - E - (B * at + F * nt)) > 0) return; } else b = !1, C = 0, Mi = !0; if ((D = yi * yi + xi * xi + di * di) > 1e-5) { if ((v = (D = (yi *= D = 1 / g.sqrt(D)) * $ + (xi *= D) * tt + (di *= D) * it) > 0) || (D = -D), (B = yi * rt + xi * lt + di * ct) < 0 && (B = -B), (F = yi * mt + xi * pt + di * ut) < 0 && (F = -F), E = B * st + F * ht, (B = yi * It + xi * Vt + di * Lt) < 0 && (B = -B), (F = yi * St + xi * Pt + di * Tt) < 0 && (F = -F), (O = D - E - (B * at + F * ot)) > 0) return; } else v = !1, O = 0, gi = !0; let Ii = z; let Vi = z; let Li = 0; let Si = a; N > Vi && (Ii = N, Vi = N, Li = 1, Si = o), k > Vi && (Ii = k, Vi = k, Li = 2, Si = n), w > Vi && (Ii = w, Vi = w, Li = 3, Si = r), M > Vi && (Ii = M, Vi = M, Li = 4, Si = l), I > Vi && (Ii = I, Vi = I, Li = 5, Si = c), V - 0.01 > Vi && !fi && (Ii = V, Vi = V - 0.01, Li = 6, Si = m), L - 0.01 > Vi && !bi && (Ii = L, Vi = L - 0.01, Li = 7, Si = p), S - 0.01 > Vi && !vi && (Ii = S, Vi = S - 0.01, Li = 8, Si = u), P - 0.01 > Vi && !zi && (Ii = P, Vi = P - 0.01, Li = 9, Si = y), T - 0.01 > Vi && !Ni && (Ii = T, Vi = T - 0.01, Li = 10, Si = x), A - 0.01 > Vi && !ki && (Ii = A, Vi = A - 0.01, Li = 11, Si = d), j - 0.01 > Vi && !wi && (Ii = j, Vi = j - 0.01, Li = 12, Si = f), C - 0.01 > Vi && !Mi && (Ii = C, Vi = C - 0.01, Li = 13, Si = b), O - 0.01 > Vi && !gi && (Ii = O, Li = 14, Si = v); let Pi = 0; let Ti = 0; let Ai = 0; let ji = 0; let Ci = 0; let Oi = 0; let Di = 0; let Ei = 0; let Bi = 0; let Fi = 0; let qi = 0; let Ui = 0; let Ri = 0; let _i = 0; let Ji = 0; let Wi = 0; let Hi = 0; let Qi = 0; let Xi = !1; if (Li == 0 ? (Si ? (Fi = Q + ft, qi = X + bt, Ui = Y + vt, Pi = rt, Ti = lt, Ai = ct) : (Fi = Q - ft, qi = X - bt, Ui = Y - vt, Pi = -rt, Ti = -lt, Ai = -ct), Ri = zt, _i = Nt, Ji = kt, ji = -mt, Ci = -pt, Oi = -ut, Wi = wt, Hi = Mt, Qi = gt, Di = -yt, Ei = -xt, Bi = -dt) : Li == 1 ? (Si ? (Fi = Q + zt, qi = X + Nt, Ui = Y + kt, Pi = mt, Ti = pt, Ai = ut) : (Fi = Q - zt, qi = X - Nt, Ui = Y - kt, Pi = -mt, Ti = -pt, Ai = -ut), Ri = ft, _i = bt, Ji = vt, ji = -rt, Ci = -lt, Oi = -ct, Wi = wt, Hi = Mt, Qi = gt, Di = -yt, Ei = -xt, Bi = -dt) : Li == 2 ? (Si ? (Fi = Q + wt, qi = X + Mt, Ui = Y + gt, Pi = yt, Ti = xt, Ai = dt) : (Fi = Q - wt, qi = X - Mt, Ui = Y - gt, Pi = -yt, Ti = -xt, Ai = -dt), Ri = ft, _i = bt, Ji = vt, ji = -rt, Ci = -lt, Oi = -ct, Wi = zt, Hi = Nt, Qi = kt, Di = -mt, Ei = -pt, Bi = -ut) : Li == 3 ? (Xi = !0, Si ? (Fi = Z - Ot, qi = K - Dt, Ui = G - Et, Pi = -It, Ti = -Vt, Ai = -Lt) : (Fi = Z + Ot, qi = K + Dt, Ui = G + Et, Pi = It, Ti = Vt, Ai = Lt), Ri = Bt, _i = Ft, Ji = qt, ji = -St, Ci = -Pt, Oi = -Tt, Wi = Ut, Hi = Rt, Qi = _t, Di = -At, Ei = -jt, Bi = -Ct) : Li == 4 ? (Xi = !0, Si ? (Fi = Z - Bt, qi = K - Ft, Ui = G - qt, Pi = -St, Ti = -Pt, Ai = -Tt) : (Fi = Z + Bt, qi = K + Ft, Ui = G + qt, Pi = St, Ti = Pt, Ai = Tt), Ri = Ot, _i = Dt, Ji = Et, ji = -It, Ci = -Vt, Oi = -Lt, Wi = Ut, Hi = Rt, Qi = _t, Di = -At, Ei = -jt, Bi = -Ct) : Li == 5 ? (Xi = !0, Si ? (Fi = Z - Ut, qi = K - Rt, Ui = G - _t, Pi = -At, Ti = -jt, Ai = -Ct) : (Fi = Z + Ut, qi = K + Rt, Ui = G + _t, Pi = At, Ti = jt, Ai = Ct), Ri = Ot, _i = Dt, Ji = Et, ji = -It, Ci = -Vt, Oi = -Lt, Wi = Bt, Hi = Ft, Qi = qt, Di = -St, Ei = -Pt, Bi = -Tt) : Li == 6 ? (Pi = Jt, Ti = Wt, Ai = Ht, ji = rt, Ci = lt, Oi = ct, Di = It, Ei = Vt, Bi = Lt) : Li == 7 ? (Pi = Qt, Ti = Xt, Ai = Yt, ji = rt, Ci = lt, Oi = ct, Di = St, Ei = Pt, Bi = Tt) : Li == 8 ? (Pi = Zt, Ti = Kt, Ai = Gt, ji = rt, Ci = lt, Oi = ct, Di = At, Ei = jt, Bi = Ct) : Li == 9 ? (Pi = $t, Ti = ti, Ai = ii, ji = mt, Ci = pt, Oi = ut, Di = It, Ei = Vt, Bi = Lt) : Li == 10 ? (Pi = si, Ti = hi, Ai = ei, ji = mt, Ci = pt, Oi = ut, Di = St, Ei = Pt, Bi = Tt) : Li == 11 ? (Pi = ai, Ti = oi, Ai = ni, ji = mt, Ci = pt, Oi = ut, Di = At, Ei = jt, Bi = Ct) : Li == 12 ? (Pi = ri, Ti = li, Ai = ci, ji = yt, Ci = xt, Oi = dt, Di = It, Ei = Vt, Bi = Lt) : Li == 13 ? (Pi = mi, Ti = pi, Ai = ui, ji = yt, Ci = xt, Oi = dt, Di = St, Ei = Pt, Bi = Tt) : Li == 14 && (Pi = yi, Ti = xi, Ai = di, ji = yt, Ci = xt, Oi = dt, Di = At, Ei = jt, Bi = Ct), Li > 5) { let Yi; let Zi; let Ki; let Gi; let $i; let ts; let is; let ss; let hs; let es; let as; Si || (Pi = -Pi, Ti = -Ti, Ai = -Ai), Zi = Pi * (ts = U[0]) + Ti * (is = U[1]) + Ai * (ss = U[2]), (Yi = Pi * (Ki = U[3]) + Ti * (Gi = U[4]) + Ai * ($i = U[5])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), (Yi = Pi * (Ki = U[6]) + Ti * (Gi = U[7]) + Ai * ($i = U[8])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), (Yi = Pi * (Ki = U[9]) + Ti * (Gi = U[10]) + Ai * ($i = U[11])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), (Yi = Pi * (Ki = U[12]) + Ti * (Gi = U[13]) + Ai * ($i = U[14])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), (Yi = Pi * (Ki = U[15]) + Ti * (Gi = U[16]) + Ai * ($i = U[17])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), (Yi = Pi * (Ki = U[18]) + Ti * (Gi = U[19]) + Ai * ($i = U[20])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), (Yi = Pi * (Ki = U[21]) + Ti * (Gi = U[22]) + Ai * ($i = U[23])) > Zi && (Zi = Yi, ts = Ki, is = Gi, ss = $i), Zi = Pi * (hs = R[0]) + Ti * (es = R[1]) + Ai * (as = R[2]), (Yi = Pi * (Ki = R[3]) + Ti * (Gi = R[4]) + Ai * ($i = R[5])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i), (Yi = Pi * (Ki = R[6]) + Ti * (Gi = R[7]) + Ai * ($i = R[8])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i), (Yi = Pi * (Ki = R[9]) + Ti * (Gi = R[10]) + Ai * ($i = R[11])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i), (Yi = Pi * (Ki = R[12]) + Ti * (Gi = R[13]) + Ai * ($i = R[14])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i), (Yi = Pi * (Ki = R[15]) + Ti * (Gi = R[16]) + Ai * ($i = R[17])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i), (Yi = Pi * (Ki = R[18]) + Ti * (Gi = R[19]) + Ai * ($i = R[20])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i), (Yi = Pi * (Ki = R[21]) + Ti * (Gi = R[22]) + Ai * ($i = R[23])) < Zi && (Zi = Yi, hs = Ki, es = Gi, as = $i); var os = ((Ki = hs - ts) * (ji - Di * (B = ji * Di + Ci * Ei + Oi * Bi)) + (Gi = es - is) * (Ci - Ei * B) + ($i = as - ss) * (Oi - Bi * B)) / (1 - B * B); s.addPoint(ts + ji * os + Pi * Ii * 0.5, is + Ci * os + Ti * Ii * 0.5, ss + Oi * os + Ai * Ii * 0.5, Pi, Ti, Ai, Ii, !1); } else { let ns; let rs; let ls; let cs; let ms; let ps; let us; let ys; let xs; let ds; let fs; let bs; let vs; let zs; let Ns; let ks; let ws; let Ms; let gs; let Is; let Vs; let Ls = 1; let Ss = 0; let Ps = 0; Xi ? ((Ss = rt * Pi + lt * Ti + ct * Ai) < Ls && (Ls = Ss, Ps = 0), -Ss < Ls && (Ls = -Ss, Ps = 1), (Ss = mt * Pi + pt * Ti + ut * Ai) < Ls && (Ls = Ss, Ps = 2), -Ss < Ls && (Ls = -Ss, Ps = 3), (Ss = yt * Pi + xt * Ti + dt * Ai) < Ls && (Ls = Ss, Ps = 4), -Ss < Ls && (Ls = -Ss, Ps = 5), Ps == 0 ? (ns = U[0], rs = U[1], ls = U[2], cs = U[6], ms = U[7], ps = U[8], us = U[9], ys = U[10], xs = U[11], ds = U[3], fs = U[4], bs = U[5]) : Ps == 1 ? (ns = U[15], rs = U[16], ls = U[17], cs = U[21], ms = U[22], ps = U[23], us = U[18], ys = U[19], xs = U[20], ds = U[12], fs = U[13], bs = U[14]) : Ps == 2 ? (ns = U[12], rs = U[13], ls = U[14], cs = U[0], ms = U[1], ps = U[2], us = U[3], ys = U[4], xs = U[5], ds = U[15], fs = U[16], bs = U[17]) : Ps == 3 ? (ns = U[21], rs = U[22], ls = U[23], cs = U[9], ms = U[10], ps = U[11], us = U[6], ys = U[7], xs = U[8], ds = U[18], fs = U[19], bs = U[20]) : Ps == 4 ? (ns = U[12], rs = U[13], ls = U[14], cs = U[18], ms = U[19], ps = U[20], us = U[6], ys = U[7], xs = U[8], ds = U[0], fs = U[1], bs = U[2]) : Ps == 5 && (ns = U[3], rs = U[4], ls = U[5], cs = R[9], ms = R[10], ps = R[11], us = U[21], ys = U[22], xs = U[23], ds = U[15], fs = U[16], bs = U[17])) : ((Ss = It * Pi + Vt * Ti + Lt * Ai) < Ls && (Ls = Ss, Ps = 0), -Ss < Ls && (Ls = -Ss, Ps = 1), (Ss = St * Pi + Pt * Ti + Tt * Ai) < Ls && (Ls = Ss, Ps = 2), -Ss < Ls && (Ls = -Ss, Ps = 3), (Ss = At * Pi + jt * Ti + Ct * Ai) < Ls && (Ls = Ss, Ps = 4), -Ss < Ls && (Ls = -Ss, Ps = 5), Ps == 0 ? (ns = R[0], rs = R[1], ls = R[2], cs = R[6], ms = R[7], ps = R[8], us = R[9], ys = R[10], xs = R[11], ds = R[3], fs = R[4], bs = R[5]) : Ps == 1 ? (ns = R[15], rs = R[16], ls = R[17], cs = R[21], ms = R[22], ps = R[23], us = R[18], ys = R[19], xs = R[20], ds = R[12], fs = R[13], bs = R[14]) : Ps == 2 ? (ns = R[12], rs = R[13], ls = R[14], cs = R[0], ms = R[1], ps = R[2], us = R[3], ys = R[4], xs = R[5], ds = R[15], fs = R[16], bs = R[17]) : Ps == 3 ? (ns = R[21], rs = R[22], ls = R[23], cs = R[9], ms = R[10], ps = R[11], us = R[6], ys = R[7], xs = R[8], ds = R[18], fs = R[19], bs = R[20]) : Ps == 4 ? (ns = R[12], rs = R[13], ls = R[14], cs = R[18], ms = R[19], ps = R[20], us = R[6], ys = R[7], xs = R[8], ds = R[0], fs = R[1], bs = R[2]) : Ps == 5 && (ns = R[3], rs = R[4], ls = R[5], cs = R[9], ms = R[10], ps = R[11], us = R[21], ys = R[22], xs = R[23], ds = R[15], fs = R[16], bs = R[17])), this.clipVertices1[0] = ns, this.clipVertices1[1] = rs, this.clipVertices1[2] = ls, this.clipVertices1[3] = cs, this.clipVertices1[4] = ms, this.clipVertices1[5] = ps, this.clipVertices1[6] = us, this.clipVertices1[7] = ys, this.clipVertices1[8] = xs, this.clipVertices1[9] = ds, this.clipVertices1[10] = fs, this.clipVertices1[11] = bs, zs = 0, B = ((ks = this.clipVertices1[9]) - Fi - Ri) * ji + ((ws = this.clipVertices1[10]) - qi - _i) * Ci + ((Ms = this.clipVertices1[11]) - Ui - Ji) * Oi; for (var Ts = 0; Ts < 4; Ts++)Ns = 3 * Ts, F = ((gs = this.clipVertices1[Ns]) - Fi - Ri) * ji + ((Is = this.clipVertices1[Ns + 1]) - qi - _i) * Ci + ((Vs = this.clipVertices1[Ns + 2]) - Ui - Ji) * Oi, B > 0 ? F > 0 ? (Ns = 3 * zs, zs++, this.clipVertices2[Ns] = gs, this.clipVertices2[Ns + 1] = Is, this.clipVertices2[Ns + 2] = Vs) : (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices2[Ns] = ks + (gs - ks) * os, this.clipVertices2[Ns + 1] = ws + (Is - ws) * os, this.clipVertices2[Ns + 2] = Ms + (Vs - Ms) * os) : F > 0 && (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices2[Ns] = ks + (gs - ks) * os, this.clipVertices2[Ns + 1] = ws + (Is - ws) * os, this.clipVertices2[Ns + 2] = Ms + (Vs - Ms) * os, Ns = 3 * zs, zs++, this.clipVertices2[Ns] = gs, this.clipVertices2[Ns + 1] = Is, this.clipVertices2[Ns + 2] = Vs), ks = gs, ws = Is, Ms = Vs, B = F; if ((vs = zs) != 0) { for (zs = 0, Ns = 3 * (vs - 1), B = ((ks = this.clipVertices2[Ns]) - Fi - Wi) * Di + ((ws = this.clipVertices2[Ns + 1]) - qi - Hi) * Ei + ((Ms = this.clipVertices2[Ns + 2]) - Ui - Qi) * Bi, Ts = 0; Ts < vs; Ts++)Ns = 3 * Ts, F = ((gs = this.clipVertices2[Ns]) - Fi - Wi) * Di + ((Is = this.clipVertices2[Ns + 1]) - qi - Hi) * Ei + ((Vs = this.clipVertices2[Ns + 2]) - Ui - Qi) * Bi, B > 0 ? F > 0 ? (Ns = 3 * zs, zs++, this.clipVertices1[Ns] = gs, this.clipVertices1[Ns + 1] = Is, this.clipVertices1[Ns + 2] = Vs) : (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices1[Ns] = ks + (gs - ks) * os, this.clipVertices1[Ns + 1] = ws + (Is - ws) * os, this.clipVertices1[Ns + 2] = Ms + (Vs - Ms) * os) : F > 0 && (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices1[Ns] = ks + (gs - ks) * os, this.clipVertices1[Ns + 1] = ws + (Is - ws) * os, this.clipVertices1[Ns + 2] = Ms + (Vs - Ms) * os, Ns = 3 * zs, zs++, this.clipVertices1[Ns] = gs, this.clipVertices1[Ns + 1] = Is, this.clipVertices1[Ns + 2] = Vs), ks = gs, ws = Is, Ms = Vs, B = F; if ((vs = zs) != 0) { for (zs = 0, Ns = 3 * (vs - 1), B = ((ks = this.clipVertices1[Ns]) - Fi + Ri) * -ji + ((ws = this.clipVertices1[Ns + 1]) - qi + _i) * -Ci + ((Ms = this.clipVertices1[Ns + 2]) - Ui + Ji) * -Oi, Ts = 0; Ts < vs; Ts++)Ns = 3 * Ts, F = ((gs = this.clipVertices1[Ns]) - Fi + Ri) * -ji + ((Is = this.clipVertices1[Ns + 1]) - qi + _i) * -Ci + ((Vs = this.clipVertices1[Ns + 2]) - Ui + Ji) * -Oi, B > 0 ? F > 0 ? (Ns = 3 * zs, zs++, this.clipVertices2[Ns] = gs, this.clipVertices2[Ns + 1] = Is, this.clipVertices2[Ns + 2] = Vs) : (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices2[Ns] = ks + (gs - ks) * os, this.clipVertices2[Ns + 1] = ws + (Is - ws) * os, this.clipVertices2[Ns + 2] = Ms + (Vs - Ms) * os) : F > 0 && (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices2[Ns] = ks + (gs - ks) * os, this.clipVertices2[Ns + 1] = ws + (Is - ws) * os, this.clipVertices2[Ns + 2] = Ms + (Vs - Ms) * os, Ns = 3 * zs, zs++, this.clipVertices2[Ns] = gs, this.clipVertices2[Ns + 1] = Is, this.clipVertices2[Ns + 2] = Vs), ks = gs, ws = Is, Ms = Vs, B = F; if ((vs = zs) != 0) { for (zs = 0, Ns = 3 * (vs - 1), B = ((ks = this.clipVertices2[Ns]) - Fi + Wi) * -Di + ((ws = this.clipVertices2[Ns + 1]) - qi + Hi) * -Ei + ((Ms = this.clipVertices2[Ns + 2]) - Ui + Qi) * -Bi, Ts = 0; Ts < vs; Ts++)Ns = 3 * Ts, F = ((gs = this.clipVertices2[Ns]) - Fi + Wi) * -Di + ((Is = this.clipVertices2[Ns + 1]) - qi + Hi) * -Ei + ((Vs = this.clipVertices2[Ns + 2]) - Ui + Qi) * -Bi, B > 0 ? F > 0 ? (Ns = 3 * zs, zs++, this.clipVertices1[Ns] = gs, this.clipVertices1[Ns + 1] = Is, this.clipVertices1[Ns + 2] = Vs) : (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices1[Ns] = ks + (gs - ks) * os, this.clipVertices1[Ns + 1] = ws + (Is - ws) * os, this.clipVertices1[Ns + 2] = Ms + (Vs - Ms) * os) : F > 0 && (Ns = 3 * zs, zs++, os = B / (B - F), this.clipVertices1[Ns] = ks + (gs - ks) * os, this.clipVertices1[Ns + 1] = ws + (Is - ws) * os, this.clipVertices1[Ns + 2] = Ms + (Vs - Ms) * os, Ns = 3 * zs, zs++, this.clipVertices1[Ns] = gs, this.clipVertices1[Ns + 1] = Is, this.clipVertices1[Ns + 2] = Vs), ks = gs, ws = Is, Ms = Vs, B = F; if (Xi) { const As = h; h = e, e = As; } if ((vs = zs) != 0) { const js = h != t; if (vs > 4) { ji = ns - (ks = 0.25 * (ns + cs + us + ds)), Ci = rs - (ws = 0.25 * (rs + ms + ys + fs)), Oi = ls - (Ms = 0.25 * (ls + ps + xs + bs)), Di = cs - ks, Ei = ms - ws, Bi = ps - Ms; let Cs = 0; let Os = 0; let Ds = 0; let Es = 0; let Bs = -this.INF; for (Ls = this.INF, Ts = 0; Ts < vs; Ts++) this.used[Ts] = !1, Ns = 3 * Ts, (Ss = (ks = this.clipVertices1[Ns]) * ji + (ws = this.clipVertices1[Ns + 1]) * Ci + (Ms = this.clipVertices1[Ns + 2]) * Oi) < Ls && (Ls = Ss, Cs = Ts), Ss > Bs && (Bs = Ss, Ds = Ts); for (this.used[Cs] = !0, this.used[Ds] = !0, Bs = -this.INF, Ls = this.INF, Ts = 0; Ts < vs; Ts++) this.used[Ts] || (Ns = 3 * Ts, (Ss = (ks = this.clipVertices1[Ns]) * Di + (ws = this.clipVertices1[Ns + 1]) * Ei + (Ms = this.clipVertices1[Ns + 2]) * Bi) < Ls && (Ls = Ss, Os = Ts), Ss > Bs && (Bs = Ss, Es = Ts)); Ns = 3 * Cs, (Ss = ((ks = this.clipVertices1[Ns]) - Fi) * Pi + ((ws = this.clipVertices1[Ns + 1]) - qi) * Ti + ((Ms = this.clipVertices1[Ns + 2]) - Ui) * Ai) < 0 && s.addPoint(ks, ws, Ms, Pi, Ti, Ai, Ss, js), Ns = 3 * Os, (Ss = ((ks = this.clipVertices1[Ns]) - Fi) * Pi + ((ws = this.clipVertices1[Ns + 1]) - qi) * Ti + ((Ms = this.clipVertices1[Ns + 2]) - Ui) * Ai) < 0 && s.addPoint(ks, ws, Ms, Pi, Ti, Ai, Ss, js), Ns = 3 * Ds, (Ss = ((ks = this.clipVertices1[Ns]) - Fi) * Pi + ((ws = this.clipVertices1[Ns + 1]) - qi) * Ti + ((Ms = this.clipVertices1[Ns + 2]) - Ui) * Ai) < 0 && s.addPoint(ks, ws, Ms, Pi, Ti, Ai, Ss, js), Ns = 3 * Es, (Ss = ((ks = this.clipVertices1[Ns]) - Fi) * Pi + ((ws = this.clipVertices1[Ns + 1]) - qi) * Ti + ((Ms = this.clipVertices1[Ns + 2]) - Ui) * Ai) < 0 && s.addPoint(ks, ws, Ms, Pi, Ti, Ai, Ss, js); } else for (Ts = 0; Ts < vs; Ts++)Ns = 3 * Ts, (Ss = ((ks = this.clipVertices1[Ns]) - Fi) * Pi + ((ws = this.clipVertices1[Ns + 1]) - qi) * Ti + ((Ms = this.clipVertices1[Ns + 2]) - Ui) * Ai) < 0 && s.addPoint(ks, ws, Ms, Pi, Ti, Ai, Ss, js); } } } } } } } }), Vt.prototype = Object.assign(Object.create(gt.prototype), {
    constructor: Vt,
    getSep(t, i, s, h, e) { let a; let o; let n; let r; let l; let c; let m; let p; let u; let y; let x; let d; let f; const b = new L(); const v = t.position.x; const z = t.position.y; const N = t.position.z; const k = i.position.x; const w = i.position.y; const M = i.position.z; const I = k - v; let V = w - z; const S = M - N; I * I + V * V + S * S == 0 && (V = 0.001); let P = -I; let T = -V; let A = -S; this.supportPointB(t, -P, -T, -A, b); let j = b.x; let C = b.y; let O = b.z; this.supportPointC(i, P, T, A, b); let D = b.x; let E = b.y; let B = b.z; let F = D - j; let q = E - C; let U = B - O; if (F * P + q * T + U * A <= 0) return !1; if ((P = q * S - U * V) * P + (T = U * I - F * S) * T + (A = F * V - q * I) * A == 0) return s.set(F - I, q - V, U - S).normalize(), h.set(0.5 * (j + D), 0.5 * (C + E), 0.5 * (O + B)), !0; this.supportPointB(t, -P, -T, -A, b); let R = b.x; let _ = b.y; let J = b.z; this.supportPointC(i, P, T, A, b); let W = b.x; let H = b.y; let Q = b.z; let X = W - R; let Y = H - _; let Z = Q - J; if (X * P + Y * T + Z * A <= 0) return !1; (P = (o = q - V) * (c = Z - S) - (n = U - S) * (l = Y - V)) * I + (T = n * (r = X - I) - (a = F - I) * c) * V + (A = a * l - o * r) * S > 0 && (a = F, o = q, n = U, F = X, q = Y, U = Z, X = a, Y = o, Z = n, a = j, o = C, n = O, j = R, C = _, O = J, R = a, _ = o, J = n, a = D, o = E, n = B, D = W, E = H, B = Q, W = a, H = o, Q = n, P = -P, T = -T, A = -A); for (let K = 0; ;) { if (++K > 100) return !1; this.supportPointB(t, -P, -T, -A, b); let G = b.x; let $ = b.y; let tt = b.z; this.supportPointC(i, P, T, A, b); let it = b.x; let st = b.y; let ht = b.z; let et = it - G; let at = st - $; let ot = ht - tt; if (et * P + at * T + ot * A <= 0) return !1; if ((q * ot - U * at) * I + (U * et - F * ot) * V + (F * at - q * et) * S < 0)X = et, Y = at, Z = ot, R = G, _ = $, J = tt, W = it, H = st, Q = ht, P = (o = q - V) * (c = ot - S) - (n = U - S) * (l = at - V), T = n * (r = et - I) - (a = F - I) * c, A = a * l - o * r; else if ((at * Z - ot * Y) * I + (ot * X - et * Z) * V + (et * Y - at * X) * S < 0)F = et, q = at, U = ot, j = G, C = $, O = tt, D = it, E = st, B = ht, P = (o = at - V) * (c = Z - S) - (n = ot - S) * (l = Y - V), T = n * (r = X - I) - (a = et - I) * c, A = a * l - o * r; else for (let nt = !1; ;) { if (P = (o = Y - q) * (c = ot - U) - (n = Z - U) * (l = at - q), T = n * (r = et - F) - (a = X - F) * c, A = a * l - o * r, (P *= m = 1 / g.sqrt(P * P + T * T + A * A)) * F + (T *= m) * q + (A *= m) * U >= 0 && !nt) { let rt = (q * Z - U * Y) * et + (U * X - F * Z) * at + (F * Y - q * X) * ot; let lt = (at * Z - ot * Y) * I + (ot * X - et * Z) * V + (et * Y - at * X) * S; let ct = (V * U - S * q) * et + (S * F - I * U) * at + (I * q - V * F) * ot; let mt = (Y * U - Z * q) * I + (Z * F - X * U) * V + (X * q - Y * F) * S; let pt = rt + lt + ct + mt; pt <= 0 && (rt = 0, pt = (lt = (Y * ot - Z * at) * P + (Z * et - X * ot) * T + (X * at - Y * et) * A) + (ct = (at * Z - ot * Y) * P + (ot * X - et * Z) * T + (et * Y - at * X) * A) + (mt = (q * Z - U * Y) * P + (U * X - F * Z) * T + (F * Y - q * X) * A)); const ut = 1 / pt; p = (v * rt + j * lt + R * ct + G * mt) * ut, u = (z * rt + C * lt + _ * ct + $ * mt) * ut, y = (N * rt + O * lt + J * ct + tt * mt) * ut, x = (k * rt + D * lt + W * ct + it * mt) * ut, d = (w * rt + E * lt + H * ct + st * mt) * ut, f = (M * rt + B * lt + Q * ct + ht * mt) * ut, nt = !0; } this.supportPointB(t, -P, -T, -A, b); const yt = b.x; const xt = b.y; const dt = b.z; this.supportPointC(i, P, T, A, b); const ft = b.x; const bt = b.y; const vt = b.z; const zt = ft - yt; const Nt = bt - xt; const kt = vt - dt; const wt = -(zt * P + Nt * T + kt * A); if ((zt - et) * P + (Nt - at) * T + (kt - ot) * A <= 0.01 || wt >= 0) return !!nt && (s.set(-P, -T, -A), h.set(0.5 * (p + x), 0.5 * (u + d), 0.5 * (y + f)), e.x = wt, !0); (Nt * U - kt * q) * I + (kt * F - zt * U) * V + (zt * q - Nt * F) * S < 0 ? (Nt * Z - kt * Y) * I + (kt * X - zt * Z) * V + (zt * Y - Nt * X) * S < 0 ? (F = zt, q = Nt, U = kt, j = yt, C = xt, O = dt, D = ft, E = bt, B = vt) : (et = zt, at = Nt, ot = kt, G = yt, $ = xt, tt = dt, it = ft, st = bt, ht = vt) : (Nt * ot - kt * at) * I + (kt * et - zt * ot) * V + (zt * at - Nt * et) * S < 0 ? (X = zt, Y = Nt, Z = kt, R = yt, _ = xt, J = dt, W = ft, H = bt, Q = vt) : (F = zt, q = Nt, U = kt, j = yt, C = xt, O = dt, D = ft, E = bt, B = vt); } } },
    supportPointB(t, i, s, h, e) { let a; let o; let n; const r = t.rotation.elements; let l = r[0] * i + r[3] * s + r[6] * h; let c = r[1] * i + r[4] * s + r[7] * h; let m = r[2] * i + r[5] * s + r[8] * h; const p = t.halfWidth; const u = t.halfHeight; const y = t.halfDepth; a = l < 0 ? -p : p, o = c < 0 ? -u : u, n = m < 0 ? -y : y, l = r[0] * a + r[1] * o + r[2] * n + t.position.x, c = r[3] * a + r[4] * o + r[5] * n + t.position.y, m = r[6] * a + r[7] * o + r[8] * n + t.position.z, e.set(l, c, m); },
    supportPointC(t, i, s, h, e) { let a; let o; let n; const r = t.rotation.elements; let l = r[0] * i + r[3] * s + r[6] * h; let c = r[1] * i + r[4] * s + r[7] * h; let m = r[2] * i + r[5] * s + r[8] * h; const p = l; const u = m; let y = p * p + u * u; const x = t.radius; const d = t.halfHeight; y == 0 ? c < 0 ? (a = x, o = -d, n = 0) : (a = x, o = d, n = 0) : (y = t.radius / g.sqrt(y), c < 0 ? (a = p * y, o = -d, n = u * y) : (a = p * y, o = d, n = u * y)), l = r[0] * a + r[1] * o + r[2] * n + t.position.x, c = r[3] * a + r[4] * o + r[5] * n + t.position.y, m = r[6] * a + r[7] * o + r[8] * n + t.position.z, e.set(l, c, m); },
    detectCollision(t, i, s) {
      let h; let e; this.flip ? (h = i, e = t) : (h = t, e = i); const a = new L(); const o = new L(); const
        n = new L(); if (this.getSep(h, e, a, o, n)) { const r = h.position.x; const l = h.position.y; const c = h.position.z; const m = e.position.x; const p = e.position.y; const u = e.position.z; const y = h.halfWidth; const x = h.halfHeight; const d = h.halfDepth; const f = e.halfHeight; const b = e.radius; const v = h.dimentions; const z = v[0]; const N = v[1]; const k = v[2]; const w = v[3]; const M = v[4]; const I = v[5]; const V = v[6]; const S = v[7]; const P = v[8]; const T = v[9]; const A = v[10]; const j = v[11]; const C = v[12]; const O = v[13]; const D = v[14]; const E = v[15]; const B = v[16]; const F = v[17]; const q = e.normalDirection.x; const U = e.normalDirection.y; const R = e.normalDirection.z; const _ = e.halfDirection.x; const J = e.halfDirection.y; const W = e.halfDirection.z; let H = a.x; let Q = a.y; let X = a.z; let Y = H * z + Q * N + X * k; let Z = H * w + Q * M + X * I; let K = H * V + Q * S + X * P; let G = H * q + Q * U + X * R; const $ = Y > 0; const tt = Z > 0; const it = K > 0; const st = G > 0; $ || (Y = -Y), tt || (Z = -Z), it || (K = -K), st || (G = -G); let ht; let et; let at; let ot; let nt; let rt; let lt; let ct; let mt; let pt; let ut; let yt; let xt; let dt; let ft; let bt; let vt; let zt; let Nt; let kt; let wt; let Mt; let gt; let It; let Vt; let Lt; let St; let Pt; let Tt; let At; let jt; let Ct; let Ot; let Dt; let Et; let Bt; let Ft; let qt; let Ut; let Rt; let _t; let Jt; let Wt; let Ht; let Qt; let Xt; let Yt; let Zt; let Kt; let Gt; let $t; let ti; let ii; let si = 0; if (G > 0.999 ? si = Y > 0.999 ? Y > G ? 1 : 4 : Z > 0.999 ? Z > G ? 2 : 4 : K > 0.999 && K > G ? 3 : 4 : Y > 0.999 ? si = 1 : Z > 0.999 ? si = 2 : K > 0.999 && (si = 3), si == 0)s.addPoint(o.x, o.y, o.z, H, Q, X, n.x, this.flip); else if (si == 4) { let hi; let ei; let ai; let oi; let ni; let ri; let li; let ci; let mi; let pi; let ui; let yi; st ? (ot = m - _, nt = p - J, rt = u - W, H = -q, Q = -U, X = -R) : (ot = m + _, nt = p + J, rt = u + W, H = q, Q = U, X = R), si = 0, (Wt = z * H + N * Q + k * X) < (kt = 1) && (kt = Wt, si = 0), -Wt < kt && (kt = -Wt, si = 1), (Wt = w * H + M * Q + I * X) < kt && (kt = Wt, si = 2), -Wt < kt && (kt = -Wt, si = 3), (Wt = V * H + S * Q + P * X) < kt && (kt = Wt, si = 4), -Wt < kt && (kt = -Wt, si = 5); const xi = h.elements; switch (si) { case 0: hi = xi[0], ei = xi[1], ai = xi[2], oi = xi[6], ni = xi[7], ri = xi[8], li = xi[9], ci = xi[10], mi = xi[11], pi = xi[3], ui = xi[4], yi = xi[5]; break; case 1: hi = xi[15], ei = xi[16], ai = xi[17], oi = xi[21], ni = xi[22], ri = xi[23], li = xi[18], ci = xi[19], mi = xi[20], pi = xi[12], ui = xi[13], yi = xi[14]; break; case 2: hi = xi[12], ei = xi[13], ai = xi[14], oi = xi[0], ni = xi[1], ri = xi[2], li = xi[3], ci = xi[4], mi = xi[5], pi = xi[15], ui = xi[16], yi = xi[17]; break; case 3: hi = xi[21], ei = xi[22], ai = xi[23], oi = xi[9], ni = xi[10], ri = xi[11], li = xi[6], ci = xi[7], mi = xi[8], pi = xi[18], ui = xi[19], yi = xi[20]; break; case 4: hi = xi[12], ei = xi[13], ai = xi[14], oi = xi[18], ni = xi[19], ri = xi[20], li = xi[6], ci = xi[7], mi = xi[8], pi = xi[0], ui = xi[1], yi = xi[2]; break; case 5: hi = xi[3], ei = xi[4], ai = xi[5], oi = xi[9], ni = xi[10], ri = xi[11], li = xi[21], ci = xi[22], mi = xi[23], pi = xi[15], ui = xi[16], yi = xi[17]; }(Nt = H * (hi - ot) + Q * (ei - nt) + X * (ai - rt)) <= 0 && s.addPoint(hi, ei, ai, -H, -Q, -X, Nt, this.flip), (Nt = H * (oi - ot) + Q * (ni - nt) + X * (ri - rt)) <= 0 && s.addPoint(oi, ni, ri, -H, -Q, -X, Nt, this.flip), (Nt = H * (li - ot) + Q * (ci - nt) + X * (mi - rt)) <= 0 && s.addPoint(li, ci, mi, -H, -Q, -X, Nt, this.flip), (Nt = H * (pi - ot) + Q * (ui - nt) + X * (yi - rt)) <= 0 && s.addPoint(pi, ui, yi, -H, -Q, -X, Nt, this.flip); } else { switch (si) { case 1: $ ? (ht = r + T, et = l + A, at = c + j, H = z, Q = N, X = k) : (ht = r - T, et = l - A, at = c - j, H = -z, Q = -N, X = -k), Xt = w, Yt = M, Zt = I, ti = x, Kt = V, Gt = S, $t = P, ii = d; break; case 2: tt ? (ht = r + C, et = l + O, at = c + D, H = w, Q = M, X = I) : (ht = r - C, et = l - O, at = c - D, H = -w, Q = -M, X = -I), Xt = z, Yt = N, Zt = k, ti = y, Kt = V, Gt = S, $t = P, ii = d; break; case 3: it ? (ht = r + E, et = l + B, at = c + F, H = V, Q = S, X = P) : (ht = r - E, et = l - B, at = c - F, H = -V, Q = -S, X = -P), Xt = z, Yt = N, Zt = k, ti = y, Kt = w, Gt = M, $t = I, ii = x; } if (ot = m + (wt = (kt = H * q + Q * U + X * R) < 0 ? f : -f) * q, nt = p + wt * U, rt = u + wt * R, G >= 0.999999 ? (Mt = -Q, gt = X, It = H) : (Mt = H, gt = Q, It = X), Lt = (wt = Mt * q + gt * U + It * R) * q - Mt, St = wt * U - gt, Pt = wt * R - It, (wt = g.sqrt(Lt * Lt + St * St + Pt * Pt)) == 0) return; if (Mt = ot + (Lt *= wt = b / wt), gt = nt + (St *= wt), It = rt + (Pt *= wt), kt < -0.96 || kt > 0.96)lt = q * q * 1.5 - 0.5, ct = q * U * 1.5 - 0.866025403 * R, mt = q * R * 1.5 + 0.866025403 * U, pt = U * q * 1.5 + 0.866025403 * R, ut = U * U * 1.5 - 0.5, yt = U * R * 1.5 - 0.866025403 * q, xt = R * q * 1.5 - 0.866025403 * U, dt = R * U * 1.5 + 0.866025403 * q, ft = R * R * 1.5 - 0.5, (qt = Xt * (Mt = (bt = Mt) - (Nt = H * (bt - ht) + Q * ((vt = gt) - et) + X * ((zt = It) - at)) * H - ht) + Yt * (gt = vt - Nt * Q - et) + Zt * (It = zt - Nt * X - at)) < -ti ? qt = -ti : qt > ti && (qt = ti), (Jt = Kt * Mt + Gt * gt + $t * It) < -ii ? Jt = -ii : Jt > ii && (Jt = ii), bt = ht + (Mt = qt * Xt + Jt * Kt), vt = et + (gt = qt * Yt + Jt * Gt), zt = at + (It = qt * Zt + Jt * $t), s.addPoint(bt, vt, zt, H, Q, X, Nt, this.flip), vt = Lt * pt + St * ut + Pt * yt, zt = Lt * xt + St * dt + Pt * ft, (Nt = H * ((bt = (Lt = bt = Lt * lt + St * ct + Pt * mt) + ot) - ht) + Q * ((vt = (St = vt) + nt) - et) + X * ((zt = (Pt = zt) + rt) - at)) <= 0 && ((qt = Xt * (Mt = bt - Nt * H - ht) + Yt * (gt = vt - Nt * Q - et) + Zt * (It = zt - Nt * X - at)) < -ti ? qt = -ti : qt > ti && (qt = ti), (Jt = Kt * Mt + Gt * gt + $t * It) < -ii ? Jt = -ii : Jt > ii && (Jt = ii), bt = ht + (Mt = qt * Xt + Jt * Kt), vt = et + (gt = qt * Yt + Jt * Gt), zt = at + (It = qt * Zt + Jt * $t), s.addPoint(bt, vt, zt, H, Q, X, Nt, this.flip)), vt = Lt * pt + St * ut + Pt * yt, zt = Lt * xt + St * dt + Pt * ft, (Nt = H * ((bt = (Lt = bt = Lt * lt + St * ct + Pt * mt) + ot) - ht) + Q * ((vt = (St = vt) + nt) - et) + X * ((zt = (Pt = zt) + rt) - at)) <= 0 && ((qt = Xt * (Mt = bt - Nt * H - ht) + Yt * (gt = vt - Nt * Q - et) + Zt * (It = zt - Nt * X - at)) < -ti ? qt = -ti : qt > ti && (qt = ti), (Jt = Kt * Mt + Gt * gt + $t * It) < -ii ? Jt = -ii : Jt > ii && (Jt = ii), bt = ht + (Mt = qt * Xt + Jt * Kt), vt = et + (gt = qt * Yt + Jt * Gt), zt = at + (It = qt * Zt + Jt * $t), s.addPoint(bt, vt, zt, H, Q, X, Nt, this.flip)); else { if (Et = Mt, kt > 0 ? (Ut = Mt + 2 * _, Rt = gt + 2 * J, _t = It + 2 * W) : (Ut = Mt - 2 * _, Rt = gt - 2 * J, _t = It - 2 * W), Mt = (Ut -= (Jt = H * (Ut - ht) + Q * (Rt - et) + X * (_t - at)) * H) - (Et -= (qt = H * (Et - ht) + Q * ((Bt = gt) - et) + X * ((Ft = It) - at)) * H), gt = (Rt -= Jt * Q) - (Bt -= qt * Q), It = (_t -= Jt * X) - (Ft -= qt * X), Vt = Jt - qt, Ht = (Z = (Ct = Ut - ht) * Xt + (Ot = Rt - et) * Yt + (Dt = _t - at) * Zt) - ti, (Wt = (Y = (Tt = Et - ht) * Xt + (At = Bt - et) * Yt + (jt = Ft - at) * Zt) - ti) > 0) { if (Ht > 0) return; Y = (Tt = (Et += Mt * (Qt = Wt / (Wt - Ht))) - ht) * Xt + (At = (Bt += gt * Qt) - et) * Yt + (jt = (Ft += It * Qt) - at) * Zt, Mt = Ut - Et, gt = Rt - Bt, It = _t - Ft, Vt = Jt - (qt += Vt * Qt); } else Ht > 0 && (Z = (Ct = (Ut = Et + Mt * (Qt = Wt / (Wt - Ht))) - ht) * Xt + (Ot = (Rt = Bt + gt * Qt) - et) * Yt + (Dt = (_t = Ft + It * Qt) - at) * Zt, Mt = Ut - Et, gt = Rt - Bt, It = _t - Ft, Vt = (Jt = qt + Vt * Qt) - qt); if (Ht = Z + ti, (Wt = Y + ti) < 0) { if (Ht < 0) return; Tt = (Et += Mt * (Qt = Wt / (Wt - Ht))) - ht, At = (Bt += gt * Qt) - et, jt = (Ft += It * Qt) - at, Mt = Ut - Et, gt = Rt - Bt, It = _t - Ft, Vt = Jt - (qt += Vt * Qt); } else Ht < 0 && (Ct = (Ut = Et + Mt * (Qt = Wt / (Wt - Ht))) - ht, Ot = (Rt = Bt + gt * Qt) - et, Dt = (_t = Ft + It * Qt) - at, Mt = Ut - Et, gt = Rt - Bt, It = _t - Ft, Vt = (Jt = qt + Vt * Qt) - qt); if (Ht = (Z = Ct * Kt + Ot * Gt + Dt * $t) - ii, (Wt = (Y = Tt * Kt + At * Gt + jt * $t) - ii) > 0) { if (Ht > 0) return; Y = (Tt = (Et += Mt * (Qt = Wt / (Wt - Ht))) - ht) * Kt + (At = (Bt += gt * Qt) - et) * Gt + (jt = (Ft += It * Qt) - at) * $t, Mt = Ut - Et, gt = Rt - Bt, It = _t - Ft, Vt = Jt - (qt += Vt * Qt); } else Ht > 0 && (Z = (Ct = (Ut = Et + Mt * (Qt = Wt / (Wt - Ht))) - ht) * Kt + (Ot = (Rt = Bt + gt * Qt) - et) * Gt + (Dt = (_t = Ft + It * Qt) - at) * $t, Mt = Ut - Et, gt = Rt - Bt, It = _t - Ft, Vt = (Jt = qt + Vt * Qt) - qt); if (Ht = Z + ii, (Wt = Y + ii) < 0) { if (Ht < 0) return; Et += Mt * (Qt = Wt / (Wt - Ht)), Bt += gt * Qt, Ft += It * Qt, qt += Vt * Qt; } else Ht < 0 && (Ut = Et + Mt * (Qt = Wt / (Wt - Ht)), Rt = Bt + gt * Qt, _t = Ft + It * Qt, Jt = qt + Vt * Qt); qt < 0 && s.addPoint(Et, Bt, Ft, H, Q, X, qt, this.flip), Jt < 0 && s.addPoint(Ut, Rt, _t, H, Q, X, Jt, this.flip); } } }
    },
  }), Lt.prototype = Object.assign(Object.create(gt.prototype), {
    constructor: Lt, getSep(t, i, s, h, e) { let a; let o; let n; let r; let l; let c; let m; let p; let u; let y; let x; let d; let f; const b = new L(); const v = t.position.x; const z = t.position.y; const N = t.position.z; const k = i.position.x; const w = i.position.y; const M = i.position.z; const I = k - v; let V = w - z; const S = M - N; I * I + V * V + S * S == 0 && (V = 0.001); let P = -I; let T = -V; let A = -S; this.supportPoint(t, -P, -T, -A, b); let j = b.x; let C = b.y; let O = b.z; this.supportPoint(i, P, T, A, b); let D = b.x; let E = b.y; let B = b.z; let F = D - j; let q = E - C; let U = B - O; if (F * P + q * T + U * A <= 0) return !1; if ((P = q * S - U * V) * P + (T = U * I - F * S) * T + (A = F * V - q * I) * A == 0) return s.set(F - I, q - V, U - S).normalize(), h.set(0.5 * (j + D), 0.5 * (C + E), 0.5 * (O + B)), !0; this.supportPoint(t, -P, -T, -A, b); let R = b.x; let _ = b.y; let J = b.z; this.supportPoint(i, P, T, A, b); let W = b.x; let H = b.y; let Q = b.z; let X = W - R; let Y = H - _; let Z = Q - J; if (X * P + Y * T + Z * A <= 0) return !1; (P = (o = q - V) * (c = Z - S) - (n = U - S) * (l = Y - V)) * I + (T = n * (r = X - I) - (a = F - I) * c) * V + (A = a * l - o * r) * S > 0 && (a = F, o = q, n = U, F = X, q = Y, U = Z, X = a, Y = o, Z = n, a = j, o = C, n = O, j = R, C = _, O = J, R = a, _ = o, J = n, a = D, o = E, n = B, D = W, E = H, B = Q, W = a, H = o, Q = n, P = -P, T = -T, A = -A); for (let K = 0; ;) { if (++K > 100) return !1; this.supportPoint(t, -P, -T, -A, b); let G = b.x; let $ = b.y; let tt = b.z; this.supportPoint(i, P, T, A, b); let it = b.x; let st = b.y; let ht = b.z; let et = it - G; let at = st - $; let ot = ht - tt; if (et * P + at * T + ot * A <= 0) return !1; if ((q * ot - U * at) * I + (U * et - F * ot) * V + (F * at - q * et) * S < 0)X = et, Y = at, Z = ot, R = G, _ = $, J = tt, W = it, H = st, Q = ht, P = (o = q - V) * (c = ot - S) - (n = U - S) * (l = at - V), T = n * (r = et - I) - (a = F - I) * c, A = a * l - o * r; else if ((at * Z - ot * Y) * I + (ot * X - et * Z) * V + (et * Y - at * X) * S < 0)F = et, q = at, U = ot, j = G, C = $, O = tt, D = it, E = st, B = ht, P = (o = at - V) * (c = Z - S) - (n = ot - S) * (l = Y - V), T = n * (r = X - I) - (a = et - I) * c, A = a * l - o * r; else for (let nt = !1; ;) { if (P = (o = Y - q) * (c = ot - U) - (n = Z - U) * (l = at - q), T = n * (r = et - F) - (a = X - F) * c, A = a * l - o * r, (P *= m = 1 / g.sqrt(P * P + T * T + A * A)) * F + (T *= m) * q + (A *= m) * U >= 0 && !nt) { let rt = (q * Z - U * Y) * et + (U * X - F * Z) * at + (F * Y - q * X) * ot; let lt = (at * Z - ot * Y) * I + (ot * X - et * Z) * V + (et * Y - at * X) * S; let ct = (V * U - S * q) * et + (S * F - I * U) * at + (I * q - V * F) * ot; let mt = (Y * U - Z * q) * I + (Z * F - X * U) * V + (X * q - Y * F) * S; let pt = rt + lt + ct + mt; pt <= 0 && (rt = 0, pt = (lt = (Y * ot - Z * at) * P + (Z * et - X * ot) * T + (X * at - Y * et) * A) + (ct = (at * Z - ot * Y) * P + (ot * X - et * Z) * T + (et * Y - at * X) * A) + (mt = (q * Z - U * Y) * P + (U * X - F * Z) * T + (F * Y - q * X) * A)); const ut = 1 / pt; p = (v * rt + j * lt + R * ct + G * mt) * ut, u = (z * rt + C * lt + _ * ct + $ * mt) * ut, y = (N * rt + O * lt + J * ct + tt * mt) * ut, x = (k * rt + D * lt + W * ct + it * mt) * ut, d = (w * rt + E * lt + H * ct + st * mt) * ut, f = (M * rt + B * lt + Q * ct + ht * mt) * ut, nt = !0; } this.supportPoint(t, -P, -T, -A, b); const yt = b.x; const xt = b.y; const dt = b.z; this.supportPoint(i, P, T, A, b); const ft = b.x; const bt = b.y; const vt = b.z; const zt = ft - yt; const Nt = bt - xt; const kt = vt - dt; const wt = -(zt * P + Nt * T + kt * A); if ((zt - et) * P + (Nt - at) * T + (kt - ot) * A <= 0.01 || wt >= 0) return !!nt && (s.set(-P, -T, -A), h.set(0.5 * (p + x), 0.5 * (u + d), 0.5 * (y + f)), e.x = wt, !0); (Nt * U - kt * q) * I + (kt * F - zt * U) * V + (zt * q - Nt * F) * S < 0 ? (Nt * Z - kt * Y) * I + (kt * X - zt * Z) * V + (zt * Y - Nt * X) * S < 0 ? (F = zt, q = Nt, U = kt, j = yt, C = xt, O = dt, D = ft, E = bt, B = vt) : (et = zt, at = Nt, ot = kt, G = yt, $ = xt, tt = dt, it = ft, st = bt, ht = vt) : (Nt * ot - kt * at) * I + (kt * et - zt * ot) * V + (zt * at - Nt * et) * S < 0 ? (X = zt, Y = Nt, Z = kt, R = yt, _ = xt, J = dt, W = ft, H = bt, Q = vt) : (F = zt, q = Nt, U = kt, j = yt, C = xt, O = dt, D = ft, E = bt, B = vt); } } }, supportPoint(t, i, s, h, e) { let a; let o; let n; const r = t.rotation.elements; let l = r[0] * i + r[3] * s + r[6] * h; let c = r[1] * i + r[4] * s + r[7] * h; let m = r[2] * i + r[5] * s + r[8] * h; const p = l; const u = m; let y = p * p + u * u; const x = t.radius; const d = t.halfHeight; y == 0 ? c < 0 ? (a = x, o = -d, n = 0) : (a = x, o = d, n = 0) : (y = t.radius / g.sqrt(y), c < 0 ? (a = p * y, o = -d, n = u * y) : (a = p * y, o = d, n = u * y)), l = r[0] * a + r[1] * o + r[2] * n + t.position.x, c = r[3] * a + r[4] * o + r[5] * n + t.position.y, m = r[6] * a + r[7] * o + r[8] * n + t.position.z, e.set(l, c, m); }, detectCollision(t, i, s) { let h; let e; t.id < i.id ? (h = t, e = i) : (h = i, e = t); let a; let o; let n; let r; let l; let c; let m; let p; let u; let y; let x; let d; let f; let b; let v; let z; let N; let k; let w; let M; let I; const V = h.position; const S = e.position; const P = V.x; const T = V.y; const A = V.z; const j = S.x; const C = S.y; const O = S.z; const D = h.halfHeight; const E = e.halfHeight; const B = h.normalDirection; const F = e.normalDirection; const q = h.halfDirection; const U = e.halfDirection; const R = h.radius; const _ = e.radius; const J = B.x; const W = B.y; const H = B.z; const Q = F.x; const X = F.y; const Y = F.z; const Z = q.x; const K = q.y; const G = q.z; const $ = U.x; const tt = U.y; const it = U.z; let st = P - j; let ht = T - C; let et = A - O; const at = new L(); const ot = new L(); const nt = new L(); if (this.getSep(h, e, at, ot, nt)) { let rt = at.x * J + at.y * W + at.z * H; let lt = at.x * Q + at.y * X + at.z * Y; const ct = rt > 0; const mt = lt > 0; ct || (rt = -rt), mt || (lt = -lt); let pt; let ut; let yt; let xt = 0; (rt > 0.999 || lt > 0.999) && (xt = rt > lt ? 1 : 2); let dt; let ft; let bt; let vt; let zt; let Nt; let kt; let wt; let Mt; let gt; let It; let Vt; let Lt; let St; let Pt; let Tt; const At = nt.x; switch (pt = at.x, ut = at.y, yt = at.z, xt) { case 0: s.addPoint(ot.x, ot.y, ot.z, pt, ut, yt, At, !1); break; case 1: if (ct ? (o = P + Z, n = T + K, r = A + G, pt = J, ut = W, yt = H) : (o = P - Z, n = T - K, r = A - G, pt = -J, ut = -W, yt = -H), l = j + (a = (w = pt * Q + ut * X + yt * Y) < 0 ? E : -E) * Q, c = C + a * X, m = O + a * Y, lt >= 0.999999 ? (p = -ut, u = yt, y = pt) : (p = pt, u = ut, y = yt), st = (a = p * Q + u * X + y * Y) * Q - p, ht = a * X - u, et = a * Y - y, (a = g.sqrt(st * st + ht * ht + et * et)) == 0) break; if (p = l + (st *= a = _ / a), u = c + (ht *= a), y = m + (et *= a), w < -0.96 || w > 0.96)dt = Q * Q * 1.5 - 0.5, ft = Q * X * 1.5 - 0.866025403 * Y, bt = Q * Y * 1.5 + 0.866025403 * X, vt = X * Q * 1.5 + 0.866025403 * Y, zt = X * X * 1.5 - 0.5, Nt = X * Y * 1.5 - 0.866025403 * Q, kt = Y * Q * 1.5 - 0.866025403 * X, wt = Y * X * 1.5 + 0.866025403 * Q, Mt = Y * Y * 1.5 - 0.5, (a = (p = (gt = p) - (Lt = pt * (gt - o) + ut * ((It = u) - n) + yt * ((Vt = y) - r)) * pt - o) * p + (u = It - Lt * ut - n) * u + (y = Vt - Lt * yt - r) * y) > R * R && (p *= a = R / g.sqrt(a), u *= a, y *= a), gt = o + p, It = n + u, Vt = r + y, s.addPoint(gt, It, Vt, pt, ut, yt, Lt, !1), It = st * vt + ht * zt + et * Nt, Vt = st * kt + ht * wt + et * Mt, (Lt = pt * ((gt = (st = gt = st * dt + ht * ft + et * bt) + l) - o) + ut * ((It = (ht = It) + c) - n) + yt * ((Vt = (et = Vt) + m) - r)) <= 0 && ((a = (p = gt - Lt * pt - o) * p + (u = It - Lt * ut - n) * u + (y = Vt - Lt * yt - r) * y) > R * R && (p *= a = R / g.sqrt(a), u *= a, y *= a), gt = o + p, It = n + u, Vt = r + y, s.addPoint(gt, It, Vt, pt, ut, yt, Lt, !1)), It = st * vt + ht * zt + et * Nt, Vt = st * kt + ht * wt + et * Mt, (Lt = pt * ((gt = (st = gt = st * dt + ht * ft + et * bt) + l) - o) + ut * ((It = (ht = It) + c) - n) + yt * ((Vt = (et = Vt) + m) - r)) <= 0 && ((a = (p = gt - Lt * pt - o) * p + (u = It - Lt * ut - n) * u + (y = Vt - Lt * yt - r) * y) > R * R && (p *= a = R / g.sqrt(a), u *= a, y *= a), gt = o + p, It = n + u, Vt = r + y, s.addPoint(gt, It, Vt, pt, ut, yt, Lt, !1)); else { if (x = p, w > 0 ? (b = p + Q * E * 2, v = u + X * E * 2, z = y + Y * E * 2) : (b = p - Q * E * 2, v = u - X * E * 2, z = y - Y * E * 2), (Tt = (St = (st = o - (x -= (N = pt * (x - o) + ut * ((d = u) - n) + yt * ((f = y) - r)) * pt)) * (p = (b -= (k = pt * (b - o) + ut * (v - n) + yt * (z - r)) * pt) - x) + (ht = n - (d -= N * ut)) * (u = (v -= k * ut) - d) + (et = r - (f -= N * yt)) * (y = (z -= k * yt) - f)) * St - (Pt = p * p + u * u + y * y) * (st * st + ht * ht + et * et - R * R)) < 0) break; (I = (St - (Tt = g.sqrt(Tt))) / Pt) < (M = (St + Tt) / Pt) && (a = M, M = I, I = a), I > 1 && (I = 1), M < 0 && (M = 0), p = x + (b - x) * M, u = d + (v - d) * M, y = f + (z - f) * M, b = x + (b - x) * I, v = d + (v - d) * I, z = f + (z - f) * I, x = p, d = u, f = y, a = N + (k - N) * M, k = N + (k - N) * I, (N = a) < 0 && s.addPoint(x, d, f, pt, ut, yt, Lt, !1), k < 0 && s.addPoint(b, v, z, pt, ut, yt, Lt, !1); } break; case 2: if (mt ? (l = j - $, c = C - tt, m = O - it, pt = -Q, ut = -X, yt = -Y) : (l = j + $, c = C + tt, m = O + it, pt = Q, ut = X, yt = Y), o = P + (a = (w = pt * J + ut * W + yt * H) < 0 ? D : -D) * J, n = T + a * W, r = A + a * H, rt >= 0.999999 ? (p = -ut, u = yt, y = pt) : (p = pt, u = ut, y = yt), st = (a = p * J + u * W + y * H) * J - p, ht = a * W - u, et = a * H - y, (a = g.sqrt(st * st + ht * ht + et * et)) == 0) break; if (p = o + (st *= a = R / a), u = n + (ht *= a), y = r + (et *= a), w < -0.96 || w > 0.96)dt = J * J * 1.5 - 0.5, ft = J * W * 1.5 - 0.866025403 * H, bt = J * H * 1.5 + 0.866025403 * W, vt = W * J * 1.5 + 0.866025403 * H, zt = W * W * 1.5 - 0.5, Nt = W * H * 1.5 - 0.866025403 * J, kt = H * J * 1.5 - 0.866025403 * W, wt = H * W * 1.5 + 0.866025403 * J, Mt = H * H * 1.5 - 0.5, (a = (p = (gt = p) - (Lt = pt * (gt - l) + ut * ((It = u) - c) + yt * ((Vt = y) - m)) * pt - l) * p + (u = It - Lt * ut - c) * u + (y = Vt - Lt * yt - m) * y) > _ * _ && (p *= a = _ / g.sqrt(a), u *= a, y *= a), gt = l + p, It = c + u, Vt = m + y, s.addPoint(gt, It, Vt, -pt, -ut, -yt, Lt, !1), It = st * vt + ht * zt + et * Nt, Vt = st * kt + ht * wt + et * Mt, (Lt = pt * ((gt = (st = gt = st * dt + ht * ft + et * bt) + o) - l) + ut * ((It = (ht = It) + n) - c) + yt * ((Vt = (et = Vt) + r) - m)) <= 0 && ((a = (p = gt - Lt * pt - l) * p + (u = It - Lt * ut - c) * u + (y = Vt - Lt * yt - m) * y) > _ * _ && (p *= a = _ / g.sqrt(a), u *= a, y *= a), gt = l + p, It = c + u, Vt = m + y, s.addPoint(gt, It, Vt, -pt, -ut, -yt, Lt, !1)), It = st * vt + ht * zt + et * Nt, Vt = st * kt + ht * wt + et * Mt, (Lt = pt * ((gt = (st = gt = st * dt + ht * ft + et * bt) + o) - l) + ut * ((It = (ht = It) + n) - c) + yt * ((Vt = (et = Vt) + r) - m)) <= 0 && ((a = (p = gt - Lt * pt - l) * p + (u = It - Lt * ut - c) * u + (y = Vt - Lt * yt - m) * y) > _ * _ && (p *= a = _ / g.sqrt(a), u *= a, y *= a), gt = l + p, It = c + u, Vt = m + y, s.addPoint(gt, It, Vt, -pt, -ut, -yt, Lt, !1)); else { if (x = p, w > 0 ? (b = p + J * D * 2, v = u + W * D * 2, z = y + H * D * 2) : (b = p - J * D * 2, v = u - W * D * 2, z = y - H * D * 2), (Tt = (St = (st = l - (x -= (N = pt * (x - l) + ut * ((d = u) - c) + yt * ((f = y) - m)) * pt)) * (p = (b -= (k = pt * (b - l) + ut * (v - c) + yt * (z - m)) * pt) - x) + (ht = c - (d -= N * ut)) * (u = (v -= k * ut) - d) + (et = m - (f -= N * yt)) * (y = (z -= k * yt) - f)) * St - (Pt = p * p + u * u + y * y) * (st * st + ht * ht + et * et - _ * _)) < 0) break; (I = (St - (Tt = g.sqrt(Tt))) / Pt) < (M = (St + Tt) / Pt) && (a = M, M = I, I = a), I > 1 && (I = 1), M < 0 && (M = 0), p = x + (b - x) * M, u = d + (v - d) * M, y = f + (z - f) * M, b = x + (b - x) * I, v = d + (v - d) * I, z = f + (z - f) * I, x = p, d = u, f = y, a = N + (k - N) * M, k = N + (k - N) * I, (N = a) < 0 && s.addPoint(x, d, f, -pt, -ut, -yt, N, !1), k < 0 && s.addPoint(b, v, z, -pt, -ut, -yt, k, !1); } } } },
  }), St.prototype = Object.assign(Object.create(gt.prototype), { constructor: St, detectCollision(t, i, s) { let h; let e; this.flip ? (h = i, e = t) : (h = t, e = i); let a; let o; let n; let r; let l; const c = e.dimentions; const m = h.position; const p = m.x; const u = m.y; const y = m.z; const x = e.position; const d = x.x; const f = x.y; const b = x.z; const v = h.radius; const z = e.halfWidth; const N = e.halfHeight; const k = e.halfDepth; let w = p - d; let M = u - f; let I = y - b; let V = c[0] * w + c[1] * M + c[2] * I; let L = c[3] * w + c[4] * M + c[5] * I; let S = c[6] * w + c[7] * M + c[8] * I; let P = 0; V > z ? V = z : V < -z ? V = -z : P = 1, L > N ? L = N : L < -N ? L = -N : P |= 2, S > k ? S = k : S < -k ? S = -k : P |= 4, P == 7 ? (I = S < 0 ? k + S : k - S, (w = V < 0 ? z + V : z - V) < (M = L < 0 ? N + L : N - L) ? w < I ? (r = w - z, V < 0 ? (V = -z, w = c[0], M = c[1], I = c[2]) : (V = z, w = -c[0], M = -c[1], I = -c[2])) : (r = I - k, S < 0 ? (S = -k, w = c[6], M = c[7], I = c[8]) : (S = k, w = -c[6], M = -c[7], I = -c[8])) : M < I ? (r = M - N, L < 0 ? (L = -N, w = c[3], M = c[4], I = c[5]) : (L = N, w = -c[3], M = -c[4], I = -c[5])) : (r = I - k, S < 0 ? (S = -k, w = c[6], M = c[7], I = c[8]) : (S = k, w = -c[6], M = -c[7], I = -c[8])), a = d + V * c[0] + L * c[3] + S * c[6], o = f + V * c[1] + L * c[4] + S * c[7], n = b + V * c[2] + L * c[5] + S * c[8], s.addPoint(p + v * w, u + v * M, y + v * I, w, M, I, r - v, this.flip)) : (a = d + V * c[0] + L * c[3] + S * c[6], o = f + V * c[1] + L * c[4] + S * c[7], n = b + V * c[2] + L * c[5] + S * c[8], (r = (w = a - m.x) * w + (M = o - m.y) * M + (I = n - m.z) * I) > 0 && r < v * v && (w *= l = 1 / (r = g.sqrt(r)), M *= l, I *= l, s.addPoint(p + v * w, u + v * M, y + v * I, w, M, I, r - v, this.flip))); } }), Pt.prototype = Object.assign(Object.create(gt.prototype), { constructor: Pt, detectCollision(t, i, s) { let h; let e; this.flip ? (h = i, e = t) : (h = t, e = i); const a = h.position; const o = a.x; const n = a.y; const r = a.z; const l = e.position; const c = l.x; const m = l.y; const p = l.z; const u = e.normalDirection.x; const { y } = e.normalDirection; const x = e.normalDirection.z; const d = h.radius; const f = e.radius; const b = d + f; const v = e.halfHeight; let z = o - c; let N = n - m; let k = r - p; let w = z * u + N * y + k * x; if (!(w < -v - d || w > v + d)) { let M; let I = c + w * u; let V = m + w * y; let L = p + w * x; let S = o - I; let P = n - V; let T = r - L; let A = S * S + P * P + T * T; if (!(A > b * b))A > f * f && (S *= A = f / g.sqrt(A), P *= A, T *= A), w < -v ? w = -v : w > v && (w = v), (A = (z = (I = c + w * u + S) - o) * z + (N = (V = m + w * y + P) - n) * N + (k = (L = p + w * x + T) - r) * k) > 0 && A < d * d && (z *= M = 1 / (A = g.sqrt(A)), N *= M, k *= M, s.addPoint(o + z * d, n + N * d, r + k * d, z, N, k, A - d, this.flip)); } } }), Tt.prototype = Object.assign(Object.create(gt.prototype), { constructor: Tt, detectCollision(t, i, s) { const h = t; const e = i; const a = h.position; const o = e.position; let n = o.x - a.x; let r = o.y - a.y; let l = o.z - a.z; let c = n * n + r * r + l * l; const m = h.radius; const p = m + e.radius; if (c > 0 && c < p * p) { const u = 1 / (c = g.sqrt(c)); n *= u, r *= u, l *= u, s.addPoint(a.x + n * m, a.y + r * m, a.z + l * m, n, r, l, c - p, !1); } } }), At.prototype = Object.assign(Object.create(gt.prototype), { constructor: At, detectCollision(t, i, s) { let h; const e = this.n; const a = this.p; const o = this.flip ? i : t; const n = this.flip ? t : i; const r = o.radius; e.sub(o.position, n.position), e.x *= n.normal.x, e.y *= n.normal.y, e.z *= n.normal.z, (h = e.lengthSq()) > 0 && h < r * r && (h = g.sqrt(h), e.copy(n.normal).negate(), a.copy(o.position).addScaledVector(e, r), s.addPointVec(a, e, h - r, this.flip)); } }), jt.prototype = Object.assign(Object.create(gt.prototype), { constructor: jt, detectCollision(t, i, s) { let h; const e = this.n; const a = this.p; const o = this.cc; const n = this.flip ? i : t; const r = this.flip ? t : i; const l = n.dimentions; const c = n.halfWidth; const m = n.halfHeight; const p = n.halfDepth; let u = 0; this.dix.set(l[0], l[1], l[2]), this.diy.set(l[3], l[4], l[5]), this.diz.set(l[6], l[7], l[8]), e.sub(n.position, r.position), e.x *= r.normal.x, e.y *= r.normal.y, e.z *= r.normal.z, o.set(g.dotVectors(this.dix, e), g.dotVectors(this.diy, e), g.dotVectors(this.diz, e)), o.x > c ? o.x = c : o.x < -c ? o.x = -c : u = 1, o.y > m ? o.y = m : o.y < -m ? o.y = -m : u |= 2, o.z > p ? o.z = p : o.z < -p ? o.z = -p : u |= 4, u === 7 && (e.set(o.x < 0 ? c + o.x : c - o.x, o.y < 0 ? m + o.y : m - o.y, o.z < 0 ? p + o.z : p - o.z), e.x < e.y ? e.x < e.z ? (h = e.x - c, o.x < 0 ? (o.x = -c, e.copy(this.dix)) : (o.x = c, e.subEqual(this.dix))) : (h = e.z - p, o.z < 0 ? (o.z = -p, e.copy(this.diz)) : (o.z = p, e.subEqual(this.diz))) : e.y < e.z ? (h = e.y - m, o.y < 0 ? (o.y = -m, e.copy(this.diy)) : (o.y = m, e.subEqual(this.diy))) : (h = e.z - p, o.z < 0 ? (o.z = -p, e.copy(this.diz)) : (o.z = p, e.subEqual(this.diz))), a.copy(r.position).addScaledVector(e, 1), s.addPointVec(a, e, h, this.flip)); } }), Object.assign(Ct.prototype, {
    World: !0, play() { if (this.timer === null) { const t = this; this.timer = setInterval(() => { t.step(); }, this.timerate); } }, stop() { this.timer !== null && (clearInterval(this.timer), this.timer = null); }, setGravity(t) { this.gravity.fromArray(t); }, getInfo() { return this.isStat ? this.performance.show() : ''; }, clear() { for (this.stop(), this.preLoop = null, this.postLoop = null, this.randX = 65535; this.joints !== null;) this.removeJoint(this.joints); for (;this.contacts !== null;) this.removeContact(this.contacts); for (;this.rigidBodies !== null;) this.removeRigidBody(this.rigidBodies); }, addRigidBody(t) { t.parent && I('World', 'It is not possible to be added to more than one world one of the rigid body'), t.setParent(this); for (let i = t.shapes; i !== null; i = i.next) this.addShape(i); this.rigidBodies !== null && ((this.rigidBodies.prev = t).next = this.rigidBodies), this.rigidBodies = t, this.numRigidBodies++; }, removeRigidBody(t) { const i = t; if (i.parent === this) { i.awake(); for (let s = i.jointLink; s != null;) { const h = s.joint; s = s.next, this.removeJoint(h); } for (let e = t.shapes; e !== null; e = e.next) this.removeShape(e); const a = i.prev; const o = i.next; a !== null && (a.next = o), o !== null && (o.prev = a), this.rigidBodies == i && (this.rigidBodies = o), i.prev = null, i.next = null, i.parent = null, this.numRigidBodies--; } }, getByName(t) { for (let i = this.rigidBodies; i !== null;) { if (i.name === t) return i; i = i.next; } for (let s = this.joints; s !== null;) { if (s.name === t) return s; s = s.next; } return null; }, addShape(t) { t.parent && t.parent.parent || I('World', 'It is not possible to be added alone to shape world'), t.proxy = this.broadPhase.createProxy(t), t.updateProxy(), this.broadPhase.addProxy(t.proxy); }, removeShape(t) { this.broadPhase.removeProxy(t.proxy), t.proxy = null; }, addJoint(t) { t.parent && I('World', 'It is not possible to be added to more than one world one of the joint'), this.joints != null && ((this.joints.prev = t).next = this.joints), this.joints = t, t.setParent(this), this.numJoints++, t.awake(), t.attach(); }, removeJoint(t) { const i = t; const s = i.prev; const h = i.next; s !== null && (s.next = h), h !== null && (h.prev = s), this.joints == i && (this.joints = h), i.prev = null, i.next = null, this.numJoints--, i.awake(), i.detach(), i.parent = null; }, addContact(t, i) { let s; this.unusedContacts !== null ? (s = this.unusedContacts, this.unusedContacts = this.unusedContacts.next) : s = new lt(), s.attach(t, i), s.detector = this.detectors[t.type][i.type], this.contacts && ((this.contacts.prev = s).next = this.contacts), this.contacts = s, this.numContacts++; }, removeContact(t) { const i = t.prev; const s = t.next; s && (s.prev = i), i && (i.next = s), this.contacts == t && (this.contacts = s), t.prev = null, t.next = null, t.detach(), t.next = this.unusedContacts, this.unusedContacts = t, this.numContacts--; }, getContact(t, i) { let s; let h; t = t.constructor === ct ? t.name : t, i = i.constructor === ct ? i.name : i; for (let e = this.contacts; e !== null;) { if (s = e.body1.name, h = e.body2.name, s === t && h === i || h === t && s === i) return e.touching ? e : null; e = e.next; } return null; }, checkContact(t, i) { for (var s, h, e = this.contacts; e !== null;) { if (s = e.body1.name || ' ', h = e.body2.name || ' ', s == t && h == i || h == t && s == i) return !!e.touching; e = e.next; } }, callSleep(t) { return !!t.allowSleep && (!(t.linearVelocity.lengthSq() > 0.04) && !(t.angularVelocity.lengthSq() > 0.25)); }, step() { const t = this.isStat; t && this.performance.setTime(0); for (var i = this.rigidBodies; i !== null;)i.addedToIsland = !1, i.sleeping && i.testWakeUp(), i = i.next; t && this.performance.setTime(1), this.broadPhase.detectPairs(); for (let s = this.broadPhase.pairs, h = this.broadPhase.numPairs; h--;) { var e; var a; var o; const n = s[h]; n.shape1.id < n.shape2.id ? (e = n.shape1, a = n.shape2) : (e = n.shape2, a = n.shape1), o = e.numContacts < a.numContacts ? e.contactLink : a.contactLink; for (var r = !1; o;) { if ((z = o.contact).shape1 == e && z.shape2 == a) { z.persisting = !0, r = !0; break; }o = o.next; }r || this.addContact(e, a); } for (t && this.performance.calcBroadPhase(), this.numContactPoints = 0, z = this.contacts; z !== null;) if (z.persisting || !z.shape1.aabb.intersectTest(z.shape2.aabb)) { const l = z.body1; const c = z.body2; (l.isDynamic && !l.sleeping || c.isDynamic && !c.sleeping) && z.updateManifold(), this.numContactPoints += z.manifold.numPoints, z.persisting = !1, z.constraint.addedToIsland = !1, z = z.next; } else { var m = z.next; this.removeContact(z), z = m; }t && this.performance.calcNarrowPhase(); let p; let u; const y = 1 / this.timeStep; for (p = this.joints; p !== null; p = p.next)p.addedToIsland = !1; this.islandRigidBodies = [], this.islandConstraints = [], this.islandStack = [], t && this.performance.setTime(1), this.numIslands = 0; for (let x = this.rigidBodies; x !== null; x = x.next) if (!(x.addedToIsland || x.isStatic || x.sleeping)) if (x.isLonely())x.isDynamic && x.linearVelocity.addScaledVector(this.gravity, this.timeStep), this.callSleep(x) ? (x.sleepTime += this.timeStep, x.sleepTime > 0.5 ? x.sleep() : x.updatePosition(this.timeStep)) : (x.sleepTime = 0, x.updatePosition(this.timeStep)), this.numIslands++; else { let d = 0; let f = 0; let b = 1; this.islandStack[0] = x, x.addedToIsland = !0; do { if (i = this.islandStack[--b], this.islandStack[b] = null, i.sleeping = !1, this.islandRigidBodies[d++] = i, !i.isStatic) { for (let v = i.contactLink; v !== null; v = v.next) { var z; if (!(u = (z = v.contact).constraint).addedToIsland && z.touching) this.islandConstraints[f++] = u, u.addedToIsland = !0, (m = v.body).addedToIsland || (this.islandStack[b++] = m, m.addedToIsland = !0); } for (let N = i.jointLink; N !== null; N = N.next)(u = N.joint).addedToIsland || (this.islandConstraints[f++] = u, u.addedToIsland = !0, !(m = N.body).addedToIsland && m.isDynamic && (this.islandStack[b++] = m, m.addedToIsland = !0)); } } while (b != 0); for (var k = (new L()).addScaledVector(this.gravity, this.timeStep), w = d; w--;)(i = this.islandRigidBodies[w]).isDynamic && i.linearVelocity.addEqual(k); if (this.enableRandomizer) for (w = f; w--;) if (w !== 0) { const M = (this.randX = this.randX * this.randA + this.randB & 2147483647) / 2147483648 * w | 0; u = this.islandConstraints[w], this.islandConstraints[w] = this.islandConstraints[M], this.islandConstraints[M] = u; } for (w = f; w--;) this.islandConstraints[w].preSolve(this.timeStep, y); for (let g = this.numIterations; g--;) for (w = f; w--;) this.islandConstraints[w].solve(); for (w = f; w--;) this.islandConstraints[w].postSolve(), this.islandConstraints[w] = null; let I = 10; for (w = d; w--;)i = this.islandRigidBodies[w], this.callSleep(i) ? (i.sleepTime += this.timeStep, i.sleepTime < I && (I = i.sleepTime)) : (i.sleepTime = 0, I = 0); if (I > 0.5) for (w = d; w--;) this.islandRigidBodies[w].sleep(), this.islandRigidBodies[w] = null; else for (w = d; w--;) this.islandRigidBodies[w].updatePosition(this.timeStep), this.islandRigidBodies[w] = null; this.numIslands++; }t && this.performance.calcEnd(), this.postLoop !== null && this.postLoop(); }, remove(t) {}, add(t) { let i = (t = t || {}).type || 'box'; return i.constructor === String && (i = [i]), i[0].substring(0, 5) === 'joint' ? this.initJoint(i[0], t) : this.initBody(i, t); }, initBody(t, i) { const s = this.invScale; const h = i.move || !1; const e = i.kinematic || !1; let a = i.pos || [0, 0, 0]; a = a.map((t) => t * s); let o = i.posShape || [0, 0, 0]; o = o.map((t) => t * s); let n = i.rot || [0, 0, 0]; n = n.map((t) => t * g.degtorad); let r = i.rotShape; r = n.map((t) => t * g.degtorad); let l = void 0 === i.size ? [1, 1, 1] : i.size; l.length === 1 && (l[1] = l[0]), l.length === 2 && (l[2] = l[0]), l = l.map((t) => t * s); const c = new F(); void 0 !== i.density && (c.density = i.density), void 0 !== i.friction && (c.friction = i.friction), void 0 !== i.restitution && (c.restitution = i.restitution), void 0 !== i.belongsTo && (c.belongsTo = i.belongsTo), void 0 !== i.collidesWith && (c.collidesWith = i.collidesWith), void 0 !== i.config && (void 0 !== i.config[0] && (c.density = i.config[0]), void 0 !== i.config[1] && (c.friction = i.config[1]), void 0 !== i.config[2] && (c.restitution = i.config[2]), void 0 !== i.config[3] && (c.belongsTo = i.config[3]), void 0 !== i.config[4] && (c.collidesWith = i.config[4])); for (var m, p, u = new ct(new L(a[0], a[1], a[2]), (new S()).setFromEuler(n[0], n[1], n[2])), y = 0; y < t.length; y++) { switch (void 0 !== o[p = 3 * y] && c.relativePosition.set(o[p], o[p + 1], o[p + 2]), void 0 !== r[p] && c.relativeRotation.setQuat((new S()).setFromEuler(r[p], r[p + 1], r[p + 2])), t[y]) { case 'sphere': m = new O(c, l[p]); break; case 'cylinder': m = new D(c, l[p], l[p + 1]); break; case 'box': m = new C(c, l[p], l[p + 1], l[p + 2]); break; case 'plane': m = new E(c); }u.addShape(m); } return i.neverSleep || e ? u.allowSleep = !1 : u.allowSleep = !0, u.isKinematic = e, h ? i.massPos || i.massRot ? u.setupMass(1, !1) : u.setupMass(1, !0) : u.setupMass(2), void 0 !== i.name && (u.name = i.name), this.addRigidBody(u), h && (i.sleep ? u.sleep() : u.awake()), u; }, initJoint(t, i) { let s; let h; const e = this.invScale; const a = i.axe1 || [1, 0, 0]; const o = i.axe2 || [1, 0, 0]; let n = i.pos1 || [0, 0, 0]; let r = i.pos2 || [0, 0, 0]; n = n.map((t) => t * e), r = r.map((t) => t * e), t === 'jointDistance' ? (s = i.min || 0, h = i.max || 10, s *= e, h *= e) : (s = i.min || 57.29578, h = i.max || 0, s *= g.degtorad, h *= g.degtorad); const l = i.limit || null; const c = i.spring || null; const m = i.motor || null; const p = new it(); p.scale = this.scale, p.invScale = this.invScale, p.allowCollision = i.collision || !1, p.localAxis1.set(a[0], a[1], a[2]), p.localAxis2.set(o[0], o[1], o[2]), p.localAnchorPoint1.set(n[0], n[1], n[2]), p.localAnchorPoint2.set(r[0], r[1], r[2]); let u; let y = null; let x = null; if (void 0 === i.body1 || void 0 === i.body2) return I('World', "Can't add joint if attach rigidbodys not define !"); if (i.body1.constructor === String ? y = this.getByName(i.body1) : i.body1.constructor === Number ? y = this.getByName(i.body1) : i.body1.constructor === ct && (y = i.body1), i.body2.constructor === String ? x = this.getByName(i.body2) : i.body2.constructor === Number ? x = this.getByName(i.body2) : i.body2.constructor === ct && (x = i.body2), y === null || x === null) return I('World', "Can't add joint attach rigidbodys not find !"); switch (p.body1 = y, p.body2 = x, t) { case 'jointDistance': u = new Y(p, s, h), c !== null && u.limitMotor.setSpring(c[0], c[1]), m !== null && u.limitMotor.setMotor(m[0], m[1]); break; case 'jointHinge': case 'joint': u = new H(p, s, h), c !== null && u.limitMotor.setSpring(c[0], c[1]), m !== null && u.limitMotor.setMotor(m[0], m[1]); break; case 'jointPrisme': u = new G(p, s, h); break; case 'jointSlide': u = new $(p, s, h); break; case 'jointBall': u = new Q(p); break; case 'jointWheel': u = new tt(p), l !== null && u.rotationalLimitMotor1.setLimit(l[0], l[1]), c !== null && u.rotationalLimitMotor1.setSpring(c[0], c[1]), m !== null && u.rotationalLimitMotor1.setMotor(m[0], m[1]); } return u.name = i.name || '', this.addJoint(u), u; },
  }), t.Math = g, t.Vec3 = L, t.Quat = S, t.Mat33 = P, t.Shape = j, t.Box = C, t.Sphere = O, t.Cylinder = D, t.Plane = E, t.Particle = B, t.ShapeConfig = F, t.LimitMotor = q, t.HingeJoint = H, t.BallAndSocketJoint = Q, t.DistanceJoint = Y, t.PrismaticJoint = G, t.SliderJoint = $, t.WheelJoint = tt, t.JointConfig = it, t.RigidBody = ct, t.World = Ct, t.REVISION = o, t.BR_NULL = n, t.BR_BRUTE_FORCE = r, t.BR_SWEEP_AND_PRUNE = l, t.BR_BOUNDING_VOLUME_TREE = c, t.BODY_NULL = m, t.BODY_DYNAMIC = 1, t.BODY_STATIC = 2, t.BODY_KINEMATIC = 3, t.BODY_GHOST = 4, t.SHAPE_NULL = p, t.SHAPE_SPHERE = u, t.SHAPE_BOX = y, t.SHAPE_CYLINDER = x, t.SHAPE_PLANE = d, t.SHAPE_PARTICLE = f, t.SHAPE_TETRA = 6, t.JOINT_NULL = b, t.JOINT_DISTANCE = v, t.JOINT_BALL_AND_SOCKET = z, t.JOINT_HINGE = N, t.JOINT_WHEEL = k, t.JOINT_SLIDER = w, t.JOINT_PRISMATIC = M, t.AABB_PROX = 0.005, t.printError = I, t.InfoDisplay = V, Object.defineProperty(t, '__esModule', { value: !0 });
}));
